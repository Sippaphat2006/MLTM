<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OKUMA CNC Dashboard – Rework</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net"/>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
<style>
  :root{
    --bg:#f6f7fb; --panel:#fff; --muted:#6b7280; --ring:#e5e7eb;
    --green:#0D8C25; --yellow:#E69400; --red:#EB0000; --grey:#9ca3af;
  }
  *{box-sizing:border-box}
  /* Full-viewport layout: sticky sidebar + no body scroll */
  body{
    margin:0;font-family:Inter,system-ui,Segoe UI,Arial,sans-serif;
    background:var(--bg);color:#111827;
    min-height:100vh; display:grid; grid-template-columns:280px 1fr;
    overflow:hidden;
  }
  /* SIDEBAR (sticky) */
  .sidebar{
    position:sticky; top:0; height:100vh; width:280px; min-width:240px;
    background:#1f2937;color:#fff;display:flex;flex-direction:column;
    padding:18px 14px;gap:14px
  }
  .brand{font-weight:800;letter-spacing:.3px}
  .tabs{display:flex;flex-direction:column;gap:10px;margin-top:8px;overflow:auto;padding-right:4px}
  .tab{display:flex;align-items:center;justify-content:space-between;gap:10px;background:#374151;border:none;color:#fff;padding:12px;border-radius:14px;cursor:pointer;transition:background .2s}
  .tab:hover{background:#4b5563}
  .tab.active{background:#111827;box-shadow:0 0 0 2px #6b7280 inset}
  .tab .title{flex:1;text-align:left}
  .dot{width:14px;height:14px;border-radius:50%;background:#9ca3af;flex:0 0 auto}
  .preview{margin-top:auto;background:#0b1220;border-radius:12px;padding:10px;text-align:center}
  .preview img{width:100%;display:block;border-radius:10px}
  .preview .cap{color:#d1d5db;font-size:14px;margin-top:6px}

  /* MAIN (fills viewport; two rows of charts that fit without page scroll) */
  .main{height:100vh;display:grid;grid-template-rows:auto 1fr 1fr;gap:10px;padding:12px;overflow:hidden}
  .panel{background:var(--panel);border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.06);padding:12px;min-height:0;display:flex;flex-direction:column}
  .panel-header{display:flex;align-items:center;gap:12px;justify-content:space-between;margin-bottom:6px}
  .title{font-weight:700}
  .muted{color:var(--muted);font-size:12px}
  .err{color:#b91c1c;font-size:12px}

  .topbar,.grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;min-height:0}
  @media (max-width: 1200px){
    .topbar{grid-template-columns:1fr}
    .grid{grid-template-columns:1fr}
    .main{grid-template-rows:auto 1fr 1fr}
  }

  .chart-wrap{position:relative;flex:1;min-height:0}
  .picker{display:flex;align-items:center;gap:8px}
  .picker input[type="date"], .picker input[type="month"]{padding:8px 10px;border:1px solid #d1d5db;border-radius:10px}
  .legend-chip{display:inline-flex;align-items:center;gap:6px;margin-right:10px}
  .chip{width:10px;height:10px;border-radius:3px;display:inline-block}
  /* segmented buttons (Panel 2) */
/* segmented buttons (Panel 2) */
  .seg-btns{display:flex;gap:6px;flex-wrap:wrap}
  .seg-btns .seg{border:1px solid #d1d5db;background:#fff;padding:6px 10px;border-radius:8px;cursor:pointer;font-size:12px}
  .seg-btns .seg.active{background:#111827;color:#fff;border-color:#111827}

  /* compact horizontal legend row (Panel 3, used later) */
  .legend-row{display:flex;gap:14px;flex-wrap:wrap;margin:4px 0 6px}
  .date-hero{
    display:flex; align-items:center; justify-content:center;
    text-align:center; font-weight:800;
    font-size:clamp(18px, 2.2vw, 28px);
    letter-spacing:.2px; padding:6px 0 2px;
  }
  .tip{position:absolute; z-index:10; pointer-events:none;
     background:rgba(17,24,39,.92); color:#fff;
     border-radius:8px; padding:6px 8px; font-size:12px;
     box-shadow:0 6px 18px rgba(0,0,0,.2)}
  .tip.hidden{display:none}
  /* compact panel chrome just for the top bar */
  .panel.compact{ padding:8px 10px; }
  .panel.compact .panel-header{ margin-bottom:4px; }

  /* put the hero inside the header without affecting layout height */
  .hero-header{ position:relative; padding:6px 0; min-height:44px; }
  .hero-header .title,
  .hero-header .picker{ position:relative; z-index:1; }  /* stay clickable */
  .date-hero.in-header{
    position:absolute; left:0; right:0; top:50%;
    transform:translateY(-50%);
    text-align:center; pointer-events:none;
    font-weight:800;
    font-size:clamp(16px, 2.0vw, 24px);  /* a touch smaller than before */
    letter-spacing:.2px;
  }

  /* tiny trims to inputs in the top bar */
  .panel.compact .picker input[type="date"]{ padding:6px 8px; }

  /* auto-hide empty rows to save vertical space */
  .err:empty, .muted:empty{ display:none; }


</style>
</head>
<body>
  <aside class="sidebar">
    <div class="brand">CNC Machine Dashboard</div>
    <div id="machineTabs" class="tabs"></div>

    <div class="preview" id="machinePreview">
      <img id="machinePreviewImg" alt="Machine photo" />
      <div class="cap" id="machinePreviewCaption">Machine photo</div>
    </div>
  </aside>

  <main class="main">

    <!-- MAIN DATE (drives all pickers) -->
    <section class="panel compact" id="mainDatePanel">
      <div class="panel-header hero-header">
        <div class="title">Select Date</div>
        <!-- ⬇︎ move the hero INSIDE the header -->
        <div id="mainDateHero" class="date-hero in-header"></div>
        <div class="picker"><input type="date" id="mainDate" /></div>
      </div>
      <div class="muted" id="contextInfo"></div>
      <div class="err" id="globalErr"></div>
    </section>


    <section class="topbar">

      <!-- Panel 1: Machine status / day -->
      <section class="panel">
        <div class="panel-header">
          <div>
            <div class="title">Machine status / day</div>
            <div class="muted">Active = Green, Setup = Yellow, Alarm = Red</div>
          </div>
          <div class="picker"><input type="date" id="p1Date"/></div>
        </div>
        <div class="chart-wrap sm"><canvas id="p1Chart"></canvas></div>
      </section>

      <!-- Panel 2: Monthly runtime overview (Active only) -->
      <section class="panel">
        <div class="panel-header">
          <div class="title" id="p2Title">Monthly runtime overview (Active)</div>
          <div class="picker"><input type="month" id="p2Month"/></div>
        </div>

        <!-- status selector -->
        <div class="seg-btns" id="p2Status" style="margin-bottom:6px">
          <button class="seg active" data-color="green">Active</button>
          <button class="seg" data-color="yellow">Setup</button>
          <button class="seg" data-color="red">Alarm</button>
        </div>

        <div class="legend-chip">
          <span class="chip" id="p2LegendChip" style="background:var(--green)"></span>
          <span class="muted" id="p2LegendText">Active time per day</span>
        </div>

        <!-- MISSING BEFORE: add the chart canvas -->
        <div class="chart-wrap sm"><canvas id="p2Chart"></canvas></div>
      </section>
    </section>

    <section class="grid">
      <!-- Panel 3: Machine running status overtime (step) -->
      <section class="panel">
        <div class="panel-header">
          <div class="title">Machine running status over time</div>
          <div class="picker"><input type="date" id="p3Date"/></div>
        </div>
        <div class="legend-row">
          <div class="legend-chip"><span class="chip" style="background:var(--green)"></span><span class="muted">Active</span></div>
          <div class="legend-chip"><span class="chip" style="background:var(--yellow)"></span><span class="muted">Setup</span></div>
          <div class="legend-chip"><span class="chip" style="background:var(--red)"></span><span class="muted">Alarm</span></div>
          <div class="legend-chip"><span class="chip" style="background:var(--grey)"></span><span class="muted">No signal</span></div>
        </div>
        <div class="chart-wrap">
          <canvas id="p3Chart"></canvas>
          <div id="p3Tip" class="tip hidden"></div>
        </div>
        <div class="muted">Time axis pinned: 07:30 → next-day 07:30 (local).</div>
      </section>

      <!-- Panel 4: Worker-reported status over time (5 states) -->
      <section class="panel">
        <div class="panel-header">
          <div class="title">Worker-reported status over time</div>
          <div class="picker"><input type="date" id="p4Date"/></div>
        </div>

        <div class="legend-row">
          <div class="legend-chip"><span class="chip" style="background:#16a34a"></span><span class="muted">RUN</span></div>
          <div class="legend-chip"><span class="chip" style="background:#f59e0b"></span><span class="muted">SETUP</span></div>
          <div class="legend-chip"><span class="chip" style="background:#0ea5e9"></span><span class="muted">WAIT MAT</span></div>
          <div class="legend-chip"><span class="chip" style="background:#8b5cf6"></span><span class="muted">WAIT TECH</span></div>
          <div class="legend-chip"><span class="chip" style="background:#f43f5e"></span><span class="muted">WAIT OP</span></div>
        </div>

        <div class="chart-wrap">
          <canvas id="p4Chart"></canvas>
          <div id="p4Tip" class="tip hidden"></div>
        </div>
        <div class="muted">Same time window: 07:30 → next-day 07:30 (local).</div>
      </section>

    </section>
  </main>

<script>
/********************** CONFIG **********************/
const API_BASE = 'http://192.168.0.233:3002/api';
const API_KEY  = '';
const SERVER_ORIGIN = API_BASE.replace(/\/api\/?$/, '');

const COLORS = { green:'#0D8C25', yellow:'#E69400', red:'#EB0000', grey:'#9ca3af',unknown:'#9ca3af' };
const LABEL  = { green:'Active',  yellow:'Setup',   red:'Alarm' };

const STEP_REFRESH_MS = 1000;
const DAY_START = { hh:7, mm:30 };

const LIVE_MS = 2000; // how often the dashboard auto-refreshes global stuff


// Panel 4 - touch status (5 states)
const TOUCH = {
  1: { key:'RUN',       color:'#16a34a' }, // green-600
  2: { key:'SETUP',     color:'#f59e0b' }, // amber-500
  3: { key:'WAIT MAT',  color:'#0ea5e9' }, // sky-500
  4: { key:'WAIT TECH', color:'#8b5cf6' }, // violet-500
  5: { key:'WAIT OP',   color:'#f43f5e' }, // rose-500
};

// === Timeline noise & merge rules (Panel 3) ===
const P3_NOISE_MS = 2000;
const P3_MERGE_GAP_MS = Infinity;


/********************** STATE **********************/
let MACHINES = [], MACHINE_META = {}, ACTIVE = null;

const el = (id) => document.getElementById(id);
const mainDate   = el('mainDate');
const contextInfo= el('contextInfo');
const globalErr  = el('globalErr');
const tabsEl     = el('machineTabs');
const previewImg = el('machinePreviewImg');
const previewCap = el('machinePreviewCaption');

let P2_STATUS = 'green';  // 'green' | 'yellow' | 'red'
const STATUS_LABEL = { green:'Active', yellow:'Setup', red:'Alarm' };

/********************** PLUGINS **********************/

const candlesPlugin = {
  id:'candlesPlugin',
  afterDraw(chart, args, opts){
    const {ctx, chartArea:{top,bottom,left,right}, scales:{x,y}} = chart;
    const bars = chart.$candles || [];
    const colW = Math.max(8, ((right-left)/Math.max(1, bars.length+2)) * 0.6);

    ctx.save();
    bars.forEach(b=>{
      const cx = x.getPixelForValue(b.idx);
      const y1 = y.getPixelForValue(b.start);
      const y2 = y.getPixelForValue(b.end);
      const a = Math.min(y1,y2), h = Math.abs(y2-y1);
      ctx.fillStyle = b.color;
      ctx.fillRect(cx - colW/2, a, colW, h);
    });

    // midnight line (horizontal, at 00:00 inside the 07:30→07:30 window)
    if (opts && opts.midnight){
      const my = y.getPixelForValue(opts.midnight);
      if (my>top && my<bottom){
        ctx.setLineDash([6,6]); ctx.strokeStyle='#9ca3af';
        ctx.beginPath(); ctx.moveTo(left, my); ctx.lineTo(right, my); ctx.stroke(); ctx.setLineDash([]);
      }
    }
    ctx.restore();
  }
};
Chart.register(candlesPlugin);


/********************** HELPERS **********************/
function toYMDLocal(d=new Date()){ const tz=d.getTimezoneOffset(); return new Date(d.getTime()-tz*60000).toISOString().slice(0,10); }
function ymOf(ymd){ return ymd.slice(0,7); }
function parseLocal(s){ return s.length===10 ? new Date(s+'T00:00:00') : new Date(s.replace(' ','T')); }
function pad2(n){ return String(n).padStart(2,'0'); }
function imagePathFor(code){
  const name=(MACHINE_META[code]?.name)||code;
  const m=String(name).match(/\d+/); const n=m?m[0]:({CNC1:14,CNC2:15,CNC3:16,CNC4:17}[code]);
  return `${SERVER_ORIGIN}/assets/machines/${encodeURIComponent(`OKUMA CNC ${n||14}.jpg`)}`;
}
async function fetchJSON(path){
  const url = path.startsWith('http')? path : `${API_BASE}${path}`;
  const headers = { 'Content-Type':'application/json' };
  if (API_KEY) headers['x-api-key'] = API_KEY;
  const res = await fetch(url, { headers, cache:'no-store' });
  if(!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json();
}

/* Get YYYY-MM-DD of the next day */
function nextYMD(ymd){
  const d = parseLocal(ymd); d.setDate(d.getDate()+1);
  return toYMDLocal(d);
}

/* Fetch [main-day timeline] + [next-day timeline], but keep only 00:00 → DAY_START slice of the next day */
async function apiTimelineSpan(code, ymd, minsAfterMidnight = DAY_START.hh*60 + DAY_START.mm /* 450 */){
  const nd = nextYMD(ymd);                               // YYYY-MM-DD (next day)
  const [today, next] = await Promise.all([
    apiTimeline(code, ymd),
    apiTimeline(code, nd)
  ]);

  const nextMid = parseLocal(nd + 'T00:00:00');
  const cutoff  = new Date(nextMid.getTime() + minsAfterMidnight*60000);

  // keep only intervals that START on/after midnight of next day
  const nextSlice = (next||[]).filter(r => {
    const s = parseLocal(r.start_time);
    return s >= nextMid && s < cutoff;
  });

  return [...(today||[]), ...nextSlice];
}
function fmtHMS(ms){
  const d = new Date(ms);
  const hh = String(d.getHours()).padStart(2,'0');
  const mm = String(d.getMinutes()).padStart(2,'0');
  const ss = String(d.getSeconds()).padStart(2,'0');
  return `${hh}:${mm}:${ss}`;
}

function prettyYMD(ymd){
  // keep your chosen format; tweak if you want localized text
  return ymd; // e.g. new Date(ymd).toLocaleDateString()
}
function updateMainHero(){ el('mainDateHero').textContent = prettyYMD(mainDate.value); }

function fmtDurHM(sec){
  let s = Math.max(0, Math.round(sec||0));
  const hh = Math.floor(s/3600);
  const mm = Math.floor((s%3600)/60);
  return `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}`;
}
function fmtDurHMS(sec){
  let s = Math.max(0, Math.round(sec||0));
  const hh = Math.floor(s/3600);
  const mm = Math.floor((s%3600)/60);
  const ss = s % 60;
  return `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
}

function cleanMergeTimeline(rows, ymd, noiseMs = P3_NOISE_MS, mergeGapMs = P3_MERGE_GAP_MS){
  const { start, end } = rangeOf(ymd);
  const now = Date.now();

  // clip ให้อยู่ในหน้าต่าง 07:30 → 07:30 และคำนวณเป็น ms
  let segs = (rows||[]).map(r => {
    const c = (r.color||'').toLowerCase();
    let a = parseLocal(r.start_time).getTime();
    let b = r.end_time ? parseLocal(r.end_time).getTime() : Math.min(now, end);
    if (b <= start || a >= end) return null;
    a = Math.max(a, start); b = Math.min(b, end);
    return { c, a, b };
  }).filter(Boolean);

  // ตัดช่วงสั้น (noise)
  segs = segs.filter(s => (s.b - s.a) > noiseMs);

  // เรียงเวลา
  segs.sort((p,q)=> (p.a - q.a) || (p.b - q.b));

  // รวมช่วงสีเดียวกันถ้าติดกัน (หรือมีกลางว่างไม่เกิน mergeGapMs)
  const out = [];
  for (const s of segs){
    const last = out[out.length - 1];
    if (last && last.c === s.c && (s.a - last.b) <= mergeGapMs){
      last.b = Math.max(last.b, s.b);
    } else {
      out.push({...s});
    }
  }
  return out; // [{c,startMs,endMs}, ...]
}



/********************** API WRAPPERS **********************/
async function apiMachines(){
  try{
    const rows = await fetchJSON('/machines');
    MACHINES = rows.map(r => r.code || r.CODE).filter(Boolean);
    MACHINE_META = {}; rows.forEach(r => { const code=r.code||r.CODE; MACHINE_META[code]={code, name:r.name||r.NAME||code}; });
    if (!ACTIVE) ACTIVE = MACHINES[0] || null;
  }catch{
    MACHINES = ['CNC1','CNC2','CNC3','CNC4'];
    MACHINE_META = { CNC1:{code:'CNC1',name:'OKUMA 20'}, CNC2:{code:'CNC2',name:'OKUMA 21'}, CNC3:{code:'CNC3',name:'OKUMA 22'}, CNC4:{code:'CNC4',name:'OKUMA 23'} };
    if (!ACTIVE) ACTIVE = 'CNC1';
  }
}
async function apiOverviewToday(){ try{ return await fetchJSON('/overview/today'); } catch { return { overview:[] }; } }
async function apiDailyBuckets(code, ymd){
  const rows = await fetchJSON(`/machines/${encodeURIComponent(code)}/status/by-date?date=${encodeURIComponent(ymd)}`);
  const sec = { green:0, yellow:0, red:0 };
  (rows||[]).forEach(r => { const c=(r.color||'').toLowerCase(); if (c in sec) sec[c]+=Number(r.seconds||0); });
  return sec;
}
async function apiTimeline(code, ymd){
  return await fetchJSON(`/machines/${encodeURIComponent(code)}/timeline?date=${encodeURIComponent(ymd)}`);
}

async function apiTouchTimeline(code, ymd){
  return await fetchJSON(`/machines/${encodeURIComponent(code)}/touch/timeline?date=${encodeURIComponent(ymd)}`);
}
async function apiTouchTimelineSpan(code, ymd, minsAfterMidnight = DAY_START.hh*60 + DAY_START.mm){
  const nd = nextYMD(ymd);
  const [today, next] = await Promise.all([
    apiTouchTimeline(code, ymd),
    apiTouchTimeline(code, nd)
  ]);
  const nextMid = parseLocal(nd + 'T00:00:00');
  const cutoff  = new Date(nextMid.getTime() + minsAfterMidnight*60000);
  const nextSlice = (next||[]).filter(r => {
    const s = parseLocal(r.start_time);
    return s >= nextMid && s < cutoff;
  });
  return [...(today||[]), ...nextSlice];
}


/********************** TABS **********************/
function renderTabs(statusByCode={}){
  tabsEl.innerHTML='';
  MACHINES.forEach(code => {
    const btn = document.createElement('button');
    btn.className = 'tab'+(code===ACTIVE?' active':'');
    btn.innerHTML = `<span class="title">${MACHINE_META[code]?.name||code}</span><span class="dot"></span>`;
    btn.onclick = () => { ACTIVE=code; updatePreview(); refreshAll(); };
    const dot = btn.querySelector('.dot');
    dot.style.background = COLORS[statusByCode[code]||'unknown'];
    tabsEl.appendChild(btn);
  });
}
function markActiveTab(){
  [...tabsEl.children].forEach(x=>x.classList.remove('active'));
  const i=MACHINES.indexOf(ACTIVE); if(i>=0) tabsEl.children[i].classList.add('active');
}
function updatePreview(){
  markActiveTab();
  previewCap.textContent = MACHINE_META[ACTIVE]?.name || ACTIVE;
  previewImg.onerror = ()=>{ previewCap.textContent='No photo'; };
  previewImg.src = imagePathFor(ACTIVE);
}

/********************** PANEL 1 – daily bar **********************/
let p1Chart;
async function drawP1(){
  const ymd = el('p1Date').value;
  const sec = await apiDailyBuckets(ACTIVE, ymd);
  p1Chart.data.datasets[0].data = [sec.green, sec.yellow, sec.red]; // seconds
  p1Chart.update();
}

/********************** PANEL 2 – monthly active-only bar **********************/
let p2Chart;
async function drawP2(){
  const ym = el('p2Month').value; // YYYY-MM
  const d0 = new Date(ym+'-01T00:00:00');
  const days = new Date(d0.getFullYear(), d0.getMonth()+1, 0).getDate();
  const labels = Array.from({length:days}, (_,i)=> String(i+1));
  const promises = labels.map((_,i)=> apiDailyBuckets(ACTIVE, `${ym}-${pad2(i+1)}`));
  const batch=6, out=[...promises], results=[];
  while(out.length){ const part=out.splice(0,batch); const vals=await Promise.allSettled(part); results.push(...vals.map(v=> v.status==='fulfilled'? v.value : {green:0,yellow:0,red:0})); }
  const secs = results.map(sec => (sec[P2_STATUS]||0)); // keep seconds
  p2Chart.data.labels = labels;
  p2Chart.data.datasets[0].data = secs;
  p2Chart.update();
}

/********************** PANEL 3 – TIMELINE (interval) **********************/
let p3Chart, p3Timer=null;

/* Plugin draws colored intervals + midnight guide on a time x-axis */
const timelinePlugin = {
  id:'timelinePlugin',
  afterDraw(chart, args, opts){
    const {ctx, chartArea:{top,bottom,left,right}, scales:{x}} = chart;
    const segs = chart.$timelineSegments || [];
    const midY = (top+bottom)/2; const barH = Math.min(26, (bottom-top)*0.32);
    ctx.save();
    segs.forEach(s=>{
      const x1 = x.getPixelForValue(s.start), x2 = x.getPixelForValue(s.end);
      if (Number.isNaN(x1)||Number.isNaN(x2)) return;
      const a=Math.max(left,Math.min(right,x1)); const b=Math.max(left,Math.min(right,x2));
      if (b<=left||a>=right) return;
      ctx.fillStyle = s.color; ctx.fillRect(a, midY-barH/2, Math.max(1,b-a), barH);
    });
    // midnight marker between the two days
    if (opts && opts.midnight){
      const xm = x.getPixelForValue(opts.midnight);
      if (xm>left && xm<right){ ctx.strokeStyle='#9ca3af'; ctx.setLineDash([6,6]); ctx.beginPath(); ctx.moveTo(xm, top); ctx.lineTo(xm, bottom); ctx.stroke(); ctx.setLineDash([]); }
    }
    ctx.restore();
  }
};
Chart.register(timelinePlugin);

function rangeOf(ymd){
  const d = parseLocal(ymd);
  const start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), DAY_START.hh, DAY_START.mm, 0).getTime();
  const end   = new Date(d.getFullYear(), d.getMonth(), d.getDate()+1, DAY_START.hh, DAY_START.mm, 0).getTime();
  const midnight = new Date(d.getFullYear(), d.getMonth(), d.getDate()+1, 0,0,0).getTime();
  return {start,end,midnight};
}
function buildSegments(timeline, ymd){
  const {start,end} = rangeOf(ymd);
  const now = Date.now();
  const segs=[];
  (timeline||[]).forEach(r=>{
    const c=(r.color||'').toLowerCase();
    let a = parseLocal(r.start_time).getTime();
    let b = r.end_time ? parseLocal(r.end_time).getTime() : Math.min(now, end);
    if (b<=start || a>=end) return;
    a=Math.max(a,start); b=Math.min(b,end);
    segs.push({start:a,end:b,color:COLORS[c]||COLORS.grey});
  });
  segs.sort((p,q)=>p.start-q.start);
  const out=[]; let cursor=start;
  for(const s of segs){ if (s.start>cursor) out.push({start:cursor,end:s.start,color:COLORS.grey}); out.push(s); cursor=Math.max(cursor,s.end); }
  if (cursor<end) out.push({start:cursor,end:end,color:COLORS.grey});
  return out;
}
async function drawP3Once(){
  const ymd = el('p3Date').value;

  // ดึงวันหลัก + ช่วงของวันถัดไป (ตัดไว้ถึง 07:30)
  const tl = await apiTimelineSpan(ACTIVE, ymd);
  const { start, end, midnight } = rangeOf(ymd);

  // ทำความสะอาด + รวมช่วง
  const merged = cleanMergeTimeline(tl, ymd);

  // สร้างข้อมูลให้ปลั๊กอินวาดแท่ง
  const candles = merged.map((s, i) => ({
    idx: i + 1,
    start: s.a,
    end:   s.b,
    color: COLORS[s.c] || COLORS.grey
  }));

  // อัปเดตสเกล/ข้อมูล
  p3Chart.options.scales.y.min = start;
  p3Chart.options.scales.y.max = end;
  p3Chart.options.scales.x.max = candles.length + 1;
  p3Chart.options.plugins.candlesPlugin.midnight = midnight;
  p3Chart.$candles = candles;
  p3Chart.update();
}



function startP3Auto(){
  stopP3Auto();
  const {start,end} = rangeOf(el('p3Date').value);
  drawP3Once();
  const now = Date.now();
  if (now>=start && now<=end) p3Timer = setInterval(drawP3Once, STEP_REFRESH_MS);
}
function stopP3Auto(){ if (p3Timer) clearInterval(p3Timer), p3Timer=null; }

/********************** PANEL 4 – placeholder **********************/
let p4Chart, p4Timer=null;

function buildTouchCandles(rows, ymd){
  const {start, end} = rangeOf(ymd);
  const now = Date.now();
  const segs=[];
  (rows||[]).forEach(r=>{
    let a = parseLocal(r.start_time).getTime();
    let b = r.end_time ? parseLocal(r.end_time).getTime() : Math.min(now, end);
    if (b<=start || a>=end) return;
    a=Math.max(a,start); b=Math.min(b,end);
    const color = (TOUCH[r.status_id]?.color) || '#9ca3af';
    segs.push({ start:a, end:b, color, emp_id:r.emp_id });
  });
  segs.sort((p,q)=>p.start-q.start);
  return segs.map((s,i)=>({ idx:i+1, start:s.start, end:s.end, color:s.color, emp_id:s.emp_id }));
}

async function drawP4Once(){
  const ymd = el('p4Date').value;
  const tl  = await apiTouchTimelineSpan(ACTIVE, ymd);
  const {start,end,midnight} = rangeOf(ymd);
  const candles = buildTouchCandles(tl, ymd);

  p4Chart.options.scales.y.min = start;
  p4Chart.options.scales.y.max = end;
  p4Chart.options.scales.x.max = candles.length + 1;
  p4Chart.options.plugins.candlesPlugin.midnight = midnight;
  p4Chart.$candles = candles;
  p4Chart.update();
}

function startP4Auto(){
  stopP4Auto();
  const {start,end} = rangeOf(el('p4Date').value);
  drawP4Once();
  const now = Date.now();
  if (now>=start && now<=end) p4Timer = setInterval(drawP4Once, STEP_REFRESH_MS);
}
function stopP4Auto(){ if (p4Timer) clearInterval(p4Timer), p4Timer=null; }



/********************** LIVE REFRESH **********************/
let liveTimer = null;

function startLiveLoops(){
  stopLiveLoops();
  // keep the interval charts running
  startP3Auto();
  startP4Auto();

  liveTimer = setInterval(async ()=>{
    try {
      // 1) refresh sidebar dots (current state for ALL machines)
      const o = await apiOverviewToday();
      const statusMap = {};
      (o.overview || []).forEach(item => {
        const code = item?.machine?.code || item?.CODE;
        const col  = (item?.current?.color || 'unknown').toLowerCase();
        if (code) statusMap[code] = col;
      });
      renderTabs(statusMap); // preserves ACTIVE
    } catch (_) {}

    // 2) refresh Panel 1 while we're in the current day window
    const ymd = mainDate.value;
    const { start, end } = rangeOf(ymd);
    const now = Date.now();
    if (now >= start && now <= end) {
      drawP1();
    }

    // 3) auto-roll the main date at the end of window (next 07:30)
    if (now > end) {
      const nd = toYMDLocal(new Date());
      if (mainDate.value !== nd) {
        mainDate.value = nd;
        el('p1Date').value = nd;
        el('p3Date').value = nd;
        el('p4Date').value = nd;
        el('p2Month').value = ymOf(nd);
        updateMainHero();
        contextInfo.textContent = `${MACHINE_META[ACTIVE]?.name||ACTIVE} · ${nd}`;

        // redraw everything for the new day
        await drawP1();
        await drawP2();
        startP3Auto();
        startP4Auto();
      }
    }
  }, LIVE_MS);
}

function stopLiveLoops(){ if (liveTimer) { clearInterval(liveTimer); liveTimer = null; } }


// base chart for P4
p4Chart = new Chart(el('p4Chart').getContext('2d'),{
  type:'scatter',
  data:{ datasets:[{ data:[] }] },
  options:{ responsive:true, maintainAspectRatio:false, parsing:false,
    scales:{
      y:{ type:'time', time:{ unit:'hour', displayFormats:{ hour:'HH:mm' } } },
      x:{ type:'linear', min:0, ticks:{ stepSize:1, precision:0 } }
    },
    plugins:{ legend:{ display:false }, tooltip:{ enabled:false }, candlesPlugin:{ midnight:null } }
  }
});

// hover tooltip (interval + emp_id)
(function attachP4Hover(){
  const tip = el('p4Tip'), c = p4Chart.canvas;
  function hide(){ tip.classList.add('hidden'); }
  function show(x, y, text){ tip.textContent=text; tip.style.left=(x+12)+'px'; tip.style.top=(y+12)+'px'; tip.classList.remove('hidden'); }
  c.addEventListener('mouseleave', hide);
  c.addEventListener('mousemove', (ev)=>{
    const rect = c.getBoundingClientRect();
    const xpx  = ev.clientX - rect.left;
    const ypx  = ev.clientY - rect.top;
    const { chartArea:{top,bottom,left,right}, scales:{x,y} } = p4Chart;
    if (xpx < left || xpx > right || ypx < top || ypx > bottom) return hide();
    const bars = p4Chart.$candles || [];
    if (!bars.length) return hide();
    const colW = Math.max(8, ((right - left) / Math.max(1, bars.length + 2)) * 0.6);
    let hit=null;
    for (const b of bars){
      const cx=x.getPixelForValue(b.idx), y1=y.getPixelForValue(b.start), y2=y.getPixelForValue(b.end);
      const ya=Math.min(y1,y2), yb=Math.max(y1,y2);
      if (xpx>=cx-colW/2 && xpx<=cx+colW/2 && ypx>=ya && ypx<=yb) { hit=b; break; }
    }
    if (!hit) return hide();
    show(xpx, ypx, `${fmtHMS(hit.start)} → ${fmtHMS(hit.end)}  •  emp ${hit.emp_id}`);
  });
})();


/********************** BOOTSTRAP **********************/
function wireP2StatusButtons(){
  const wrap = document.getElementById('p2Status');
  if (!wrap) return; // safety

  wrap.addEventListener('click', (e)=>{
    const btn = e.target.closest('button[data-color]');
    if(!btn) return;

    P2_STATUS = btn.dataset.color;
    [...wrap.querySelectorAll('.seg')].forEach(b=>b.classList.toggle('active', b===btn));

    // reflect in UI + dataset
    el('p2Title').textContent = `Monthly runtime overview (${STATUS_LABEL[P2_STATUS]})`;
    el('p2LegendText').textContent = `${STATUS_LABEL[P2_STATUS]} time per day`;
    el('p2LegendChip').style.background = COLORS[P2_STATUS];
    el('p4Date').value = toYMDLocal(new Date());


    if (p2Chart) {
      p2Chart.data.datasets[0].label = `${STATUS_LABEL[P2_STATUS]} time per day`;
      p2Chart.data.datasets[0].backgroundColor = COLORS[P2_STATUS];
      drawP2();
    }
  });
}


(async function boot(){
  const today = toYMDLocal(new Date());
  mainDate.value = today;
  updateMainHero();
  el('p1Date').value = today;
  el('p3Date').value = today;
  el('p2Month').value = ymOf(today);
  el('p4Date').value = today;


  p1Chart = new Chart(el('p1Chart').getContext('2d'),{
    type:'bar',
    data:{
      labels:[LABEL.green, LABEL.yellow, LABEL.red],
      datasets:[{
        label:'Time per day',            // was: 'Hours'
        data:[0,0,0],
        backgroundColor:[COLORS.green, COLORS.yellow, COLORS.red],
        borderWidth:0, categoryPercentage:0.6, barPercentage:0.7
      }]
    },
    options:{
      responsive:true, maintainAspectRatio:false,
      scales:{
        y:{
          beginAtZero:true,
          min:0,
          max:24*3600,                    // 24h in seconds
          ticks:{
            stepSize:2*3600,              // 2h grid
            callback:(v)=>fmtDurHM(v)
          },
          title:{ display:true, text:'Time' }
        }
      },
      plugins:{
        legend:{ display:false },
        tooltip:{
          callbacks:{
            label:(ctx)=> `${ctx.dataset.label}: ${fmtDurHMS(ctx.parsed.y)}`
          }
        }
      }
    }
  });


  p2Chart = new Chart(el('p2Chart').getContext('2d'),{
    type:'bar',
    data:{ labels:[], datasets:[{ label:'Active time per day', data:[], backgroundColor:COLORS.green }] },
    options:{
      responsive:true, maintainAspectRatio:false,
      scales:{
        y:{
          beginAtZero:true,
          min:0, max:24*3600,
          ticks:{ stepSize:2*3600, callback:(v)=>fmtDurHM(v) },
          title:{ display:true, text:'Time' }
        },
        x:{ title:{ display:true, text:'Day of month' } }
      },
      plugins:{
        legend:{ display:false },
        tooltip:{
          callbacks:{
            label:(ctx)=> `${ctx.dataset.label}: ${fmtDurHMS(ctx.parsed.y)}`
          }
        }
      }
    }
  });
  wireP2StatusButtons();

  /* Panel 3 base chart (rectangles painted by candlesPlugin) */
  p3Chart = new Chart(el('p3Chart').getContext('2d'),{
    type:'scatter',
    data:{ datasets:[{ data:[] }] },
    options:{ responsive:true, maintainAspectRatio:false, parsing:false,
      scales:{
        y:{ type:'time', time:{ unit:'hour', displayFormats:{ hour:'HH:mm' } } },
        x:{ type:'linear', min:0, ticks:{ stepSize:1, precision:0 } }
      },
      plugins:{ legend:{ display:false }, tooltip:{ enabled:false }, candlesPlugin:{ midnight:null } }
    }
  });
  // hover tooltip for P3
  const tip = el('p3Tip');
  (function attachP3Hover(){
    const c = p3Chart.canvas;
    function hide(){ tip.classList.add('hidden'); }
    function show(x, y, text){
      tip.textContent = text;
      tip.style.left = (x + 12) + 'px';
      tip.style.top  = (y + 12) + 'px';
      tip.classList.remove('hidden');
    }
    c.addEventListener('mouseleave', hide);
    c.addEventListener('mousemove', (ev)=>{
      const rect = c.getBoundingClientRect();
      const xpx  = ev.clientX - rect.left;
      const ypx  = ev.clientY - rect.top;

      const { chartArea:{top,bottom,left,right}, scales:{x,y} } = p3Chart;

      // out of plotting area → hide
      if (xpx < left || xpx > right || ypx < top || ypx > bottom) return hide();

      // bars we actually drew
      const bars = p3Chart.$candles || [];
      if (!bars.length) return hide();

      // same column width the plugin uses
      const colW = Math.max(8, ((right - left) / Math.max(1, bars.length + 2)) * 0.6);

      // find the bar under the cursor using pixel geometry
      let hit = null;
      for (const b of bars) {
        const cx = x.getPixelForValue(b.idx);
        const y1 = y.getPixelForValue(b.start);
        const y2 = y.getPixelForValue(b.end);
        const ya = Math.min(y1, y2), yb = Math.max(y1, y2);

        const insideX = (xpx >= cx - colW/2) && (xpx <= cx + colW/2);
        const insideY = (ypx >= ya) && (ypx <= yb);
        if (insideX && insideY) { hit = b; break; }
      }
      if (!hit) return hide();

      show(xpx, ypx, `${fmtHMS(hit.start)} → ${fmtHMS(hit.end)}`);
    });
  })();
  

  await apiMachines();
  const o = await apiOverviewToday();
  const statusMap={}; (o.overview||[]).forEach(item=>{ const code=item?.machine?.code||item?.CODE; if(!code) return; const col=(item?.current?.color||'unknown').toLowerCase(); statusMap[code]=col; });
  renderTabs(statusMap); updatePreview();

  contextInfo.textContent = `${MACHINE_META[ACTIVE]?.name||ACTIVE} · ${mainDate.value}`;
  globalErr.textContent='';

  await drawP1(); await drawP2(); startLiveLoops();

  mainDate.addEventListener('change', ()=>{
    const ymd = mainDate.value;
    el('p1Date').value = ymd; el('p3Date').value = ymd; el('p4Date').value = ymd;
    const ym = ymOf(ymd); 
    el('p2Month').value = ym; 
    contextInfo.textContent = `${MACHINE_META[ACTIVE]?.name||ACTIVE} · ${ymd}`;
    refreshAll();
    updateMainHero();
  });
  el('p1Date').addEventListener('change', ()=> drawP1());
  el('p2Month').addEventListener('change', ()=> drawP2());
  el('p3Date').addEventListener('change', ()=> startP3Auto());
  el('p4Date').addEventListener('change', ()=> startP4Auto());

})();


async function refreshAll(){
  globalErr.textContent='';
  try{
    updatePreview();
    contextInfo.textContent = `${MACHINE_META[ACTIVE]?.name||ACTIVE} · ${mainDate.value}`;
    await drawP1(); await drawP2(); startLiveLoops();
  }catch(e){ globalErr.textContent = e.message||String(e); }
}
</script>


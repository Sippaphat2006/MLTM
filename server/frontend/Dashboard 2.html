<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OKUMA CNC Dashboard</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net"/>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
<style>
  :root{
    --bg:#f6f7fb; --panel:#fff; --muted:#6b7280; --ring:#e5e7eb;
    --green:#0D8C25; --yellow:#E69400; --red:#EB0000; --gray:#9ca3af;
    --sidebar-width: 280px;
    --sidebar-bg: #1f2937;
  }
  *{box-sizing:border-box}
  body{
    margin:0;font-family:Inter,system-ui,Segoe UI,Arial,sans-serif;
    background:var(--bg);color:#111827;
    min-height:100vh; display:grid;
    grid-template-columns: var(--sidebar-width) 1fr;
    overflow:hidden;
    transition: grid-template-columns .3s ease-in-out;
  }
  body.sidebar-collapsed {
    grid-template-columns: 0px 1fr;
  }

  /* SIDEBAR (sticky) */
  .sidebar{
    position:sticky; top:0; height:100vh; width:var(--sidebar-width);
    background:var(--sidebar-bg);color:#fff;display:flex;flex-direction:column;
    padding:18px 14px;gap:14px;
    transform: translateX(0);
    transition: transform .3s ease-in-out, width .3s ease-in-out;
    overflow: hidden;
  }
  body.sidebar-collapsed .sidebar {
    transform: translateX(-100%);
    width: 0;
    padding: 18px 0;
  }
  .sidebar-header { display: flex; align-items: center; justify-content: space-between; padding-right: 10px; }
  .brand{font-weight:800;letter-spacing:.3px; flex: 1;}

  /* Hamburger Menu Button */
  .hamburger {
    display: flex; flex-direction: column; justify-content: space-around;
    width: 24px; height: 24px; background: transparent; border: none;
    cursor: pointer; padding: 0; z-index: 10;
  }
  .hamburger .line {
    width: 24px; height: 2px; background-color: #fff; border-radius: 2px;
    transition: all 0.3s linear;
  }
  /* Styles for menu toggle button in the main content area */
  .menu-toggle {
    position: absolute; top: 12px; left: 12px;
    width: 22px; height: 22px; background: #fff; border-radius: 50%;
    border: 1px solid var(--ring); cursor: pointer;
    display: none; /* Hidden by default */
    align-items: center; justify-content: center;
    box-shadow: 0 4px 12px rgba(0,0,0,.08);
    z-index: 100; /* Ensure it's on top */
  }
  body.sidebar-collapsed .menu-toggle { display: flex; }
  .menu-toggle .line { background-color: #374151; width: 3px; height: 2px; margin: 2px 0; border-radius: 2px; }


  .tabs{display:flex;flex-direction:column;gap:10px;margin-top:8px;overflow:auto;padding-right:4px}
  .tab{display:flex;align-items:center;justify-content:space-between;gap:10px;background:#374151;border:none;color:#fff;padding:12px;border-radius:14px;cursor:pointer;transition:background .2s}
  .tab:hover{background:#4b5563}
  .tab.active{background:#111827;box-shadow:0 0 0 2px #6b7280 inset}
  .tab .title{flex:1;text-align:left}
  .dot{width:14px;height:14px;border-radius:50%;background:#9ca3af;flex:0 0 auto}
  .preview{margin-top:auto;background:#0b1220;border-radius:12px;padding:10px;text-align:center}
  .preview img{width:100%;display:block;border-radius:10px}
  .preview .cap{color:#d1d5db;font-size:14px;margin-top:6px}

  /* MAIN (fills viewport; two rows of charts that fit without page scroll) */
  .main{height:100vh;display:grid;grid-template-rows:auto 1fr 1fr;gap:10px;padding:12px;overflow:hidden; position: relative;}
  .panel{background:var(--panel);border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.06);padding:12px;min-height:0;display:flex;flex-direction:column; position: relative;}
  .panel-header{display:flex;align-items:center;gap:12px;justify-content:space-between;margin-bottom:6px}
  .title{font-weight:700}
  .muted{color:var(--muted);font-size:12px}
  .err{color:#b91c1c;font-size:12px}

  /* Loading Overlay - permanently hidden */
  .loading-overlay { display: none !important; }

  .topbar,.grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;min-height:0}
  @media (max-width: 1200px){
    .topbar{grid-template-columns:1fr}
    .grid{grid-template-columns:1fr}
    .main{grid-template-rows:auto 1fr 1fr}
  }

  .chart-wrap{position:relative;flex:1;min-height:0}
  .picker{display:flex;align-items:center;gap:8px}
  .picker input[type="date"], .picker input[type="month"]{padding:8px 10px;border:1px solid #d1d5db;border-radius:10px}
  .legend-chip{display:inline-flex;align-items:center;gap:6px;margin-right:10px}
  .chip{width:10px;height:10px;border-radius:3px;display:inline-block}

  .seg-btns{display:flex;gap:6px;flex-wrap:wrap}
  .seg-btns .seg{border:1px solid #000000;background:#fff;padding:6px 10px;border-radius:8px;cursor:pointer;font-size:12px} 
  .seg-btns .seg.active{background:#353535;color:#fff;border-color:#111827}

  .legend-row{display:flex;gap:14px;flex-wrap:wrap;margin:4px 0 6px}
  .date-hero{
    display:flex; align-items:center; justify-content:center;
    text-align:center; font-weight:800;
    font-size:clamp(18px, 2.2vw, 28px);
    letter-spacing:.2px; padding:6px 0 2px;
  }
  .tip{position:absolute; z-index:10; pointer-events:none;
     background:rgba(17,24,39,.92); color:#fff;
     border-radius:8px; padding:6px 8px; font-size:12px;
     box-shadow:0 6px 18px rgba(0,0,0,.2)}
  .tip.hidden{display:none}

  .panel.compact{ padding:8px 10px; }
  .panel.compact .panel-header{ margin-bottom:4px; }

  .hero-header{ position:relative; padding:6px 0; min-height:44px; }
  .hero-header .title-wrap{ display:flex; align-items:center; gap:8px; position:relative; z-index:1; } /* New style for title and dot */
  .hero-header .dot{ width:18px; height:18px; flex-shrink:0; } /* Larger dot for header */
  .date-hero.in-header{
    position:absolute; left:0; right:0; top:50%;
    transform:translateY(-50%);
    text-align:center; pointer-events:none;
    font-weight:800;
    font-size:clamp(16px, 2.0vw, 24px);
    letter-spacing:.2px;
  }
  .panel.compact .picker input[type="date"]{ padding:6px 8px; }
  .err:empty, .muted:empty{ display:none; }
</style>
</head>
<body>
  <aside class="sidebar">
    <div class="sidebar-header">
      <div class="brand">CNC Dashboard</div>
      <button class="hamburger" id="hamburger-close">
          <div class="line"></div><div class="line"></div><div class="line"></div>
      </button>
    </div>
    <div id="machineTabs" class="tabs"></div>
    <div class="preview" id="machinePreview">
      <img id="machinePreviewImg" alt="Machine photo" />
      <div class="cap" id="machinePreviewCaption">Machine photo</div>
    </div>
  </aside>

  <main class="main">
    <button class="menu-toggle" id="hamburger-open">
        <div class="line"></div><div class="line"></div><div class="line"></div>
    </button>
    <section class="panel compact" id="mainDatePanel">
      <div class="panel-header hero-header">
        <div class="title-wrap"> <div class="title" id="contextTitle"></div>
          <span class="dot" id="contextStatusDot"></span> </div>
        <div id="mainDateHero" class="date-hero in-header"></div>
        <div class="picker"><input type="date" id="mainDate" /></div>
      </div>
      <div class="err" id="globalErr"></div>
    </section>

    <section class="topbar">
      <section class="panel" id="p1Panel">
        <div class="panel-header">
          <div><div class="title">Machine status / day</div></div>
          <div class="picker"><input type="date" id="p1Date"/></div>
        </div>
        <div class="legend-row">
          <div class="legend-chip"><span class="chip" style="background:var(--green)"></span><span class="muted">Run</span></div>
          <div class="legend-chip"><span class="chip" style="background:var(--yellow)"></span><span class="muted">Wait</span></div>
          <div class="legend-chip"><span class="chip" style="background:var(--red)"></span><span class="muted">Alarm</span></div>
          <div class="legend-chip"><span class="chip" style="background:var(--gray)"></span><span class="muted">Off/Sleep</span></div>
        </div>
        <div class="chart-wrap sm"><canvas id="p1Chart"></canvas></div>
        <div class="loading-overlay"></div>
      </section>

      <section class="panel" id="p2Panel">
        <div class="panel-header">
          <div class="title" id="p2Title">Monthly runtime overview (Active)</div>
          <div class="picker"><input type="month" id="p2Month"/></div>
        </div>
        <div class="seg-btns" id="p2Status" style="margin-bottom:6px">
          <button class="seg active" data-color="green">Run</button>
          <button class="seg" data-color="yellow">Wait</button>
          <button class="seg" data-color="red">Alarm</button>
          <button class="seg" data-color="gray">Off/Sleep</button>
          <button class="seg" data-mode="summary">Summary</button>
        </div>
        <div class="legend-chip">
          <span class="chip" id="p2LegendChip" style="background:var(--green)"></span>
          <span class="muted" id="p2LegendText">Active time per day</span>
        </div>
        <div class="chart-wrap sm"><canvas id="p2Chart"></canvas></div>
        <div class="loading-overlay"></div>
      </section>
    </section>

    <section class="grid">
      <section class="panel" id="p3Panel">
        <div class="panel-header">
          <div class="title">Machine running status over time</div>
          <div class="picker"><input type="date" id="p3Date"/></div>
        </div>
        <div class="legend-row">
          <div class="legend-chip"><span class="chip" style="background:var(--green)"></span><span class="muted">Run</span></div>
          <div class="legend-chip"><span class="chip" style="background:var(--yellow)"></span><span class="muted">Wait</span></div>
          <div class="legend-chip"><span class="chip" style="background:var(--red)"></span><span class="muted">Alarm</span></div>
          <div class="legend-chip"><span class="chip" style="background:var(--gray)"></span><span class="muted">Off/Sleep</span></div>
        </div>
        <div class="chart-wrap">
          <canvas id="p3Chart"></canvas>
          <div id="p3Tip" class="tip hidden"></div>
        </div>
        <div class="muted">Time axis pinned: 07:30 → next-day 07:30</div>
        <div class="loading-overlay"></div>
      </section>

      <section class="panel" id="p4Panel">
        <div class="panel-header">
          <div class="title">Worker-reported status over time</div>
          <div class="picker"><input type="date" id="p4Date"/></div>
        </div>
        <div class="legend-row">
          <div class="legend-chip"><span class="chip" style="background:#0D8C25"></span><span class="muted">RUN</span></div>
          <div class="legend-chip"><span class="chip" style="background:#f59e0b"></span><span class="muted">SETUP</span></div>
          <div class="legend-chip"><span class="chip" style="background:#0ea5e9"></span><span class="muted">WAIT MAT</span></div>
          <div class="legend-chip"><span class="chip" style="background:#8b5cf6"></span><span class="muted">WAIT TECH</span></div>
          <div class="legend-chip"><span class="chip" style="background:#f43f5e"></span><span class="muted">WAIT OP</span></div>
        </div>
        <div class="chart-wrap">
          <canvas id="p4Chart"></canvas>
          <div id="p4Tip" class="tip hidden"></div>
        </div>
        <div class="muted">Time axis pinned: 07:30 → next-day 07:30</div>
        <div class="loading-overlay"></div>
      </section>
    </section>
  </main>

<script>
/********************** CONFIG **********************/
const API_BASE = 'http://192.168.0.233:3002/api';
const API_KEY  = '';
const SERVER_ORIGIN = API_BASE.replace(/\/api\/?$/, '');

const COLORS = { green:'#0D8C25', yellow:'#E69400', red:'#EB0000', gray:'#9ca3af',unknown:'#9ca3af' };
const LABEL  = { green:'Run',  yellow:'Wait',   red:'Alarm' , gray:'Off/Sleep', unknown:'Off/Sleep' };

const STEP_REFRESH_MS = 1000;
const DAY_START = { hh:7, mm:30 };
const LIVE_MS = 2000;
const AUTO_ROLL_MAINDATE = false;

const TOUCH = {
  1: { key:'RUN',       color:'#16a34a' }, 2: { key:'SETUP',     color:'#f59e0b' },
  3: { key:'WAIT MAT',  color:'#0ea5e9' }, 4: { key:'WAIT TECH', color:'#8b5cf6' },
  5: { key:'WAIT OP',   color:'#f43f5e' }
};

const P3_NOISE_MS = 2000;
const P3_MERGE_GAP_MS = 300000;

/********************** STATE **********************/
let MACHINES = [], MACHINE_META = {}, ACTIVE = null;
let CURRENT_MACHINE_STATUS = {}; // To store current status for all machines

const el = (id) => document.getElementById(id);
const mainDate   = el('mainDate');
const globalErr  = el('globalErr');
const tabsEl     = el('machineTabs');
const previewImg = el('machinePreviewImg');
const previewCap = el('machinePreviewCaption');
const contextTitleEl = el('contextTitle');
const contextStatusDotEl = el('contextStatusDot');

let P2_STATUS = 'green';
let P2_MODE   = 'single';
const STATUS_LABEL = { green:'Run', yellow:'Wait', red:'Alarm', gray:'Off/Sleep' };

/********************** PLUGINS **********************/
const candlesPlugin = {
  id:'candlesPlugin',
  afterDraw(chart, args, opts){
    const {ctx, chartArea:{top,bottom,left,right}, scales:{x,y}} = chart;
    const bars = chart.$candles || [];
    const colW = Math.max(8, ((right-left)/Math.max(1, bars.length+2)) * 0.6);

    ctx.save();
    bars.forEach(b=>{
      const cx = x.getPixelForValue(b.idx);
      const y1 = y.getPixelForValue(b.start);
      const y2 = y.getPixelForValue(b.end);
      const a = Math.min(y1,y2), h = Math.abs(y2-y1);
      ctx.fillStyle = b.color;
      ctx.fillRect(cx - colW/2, a, colW, h);
    });

    if (opts && opts.midnight){
      const my = y.getPixelForValue(opts.midnight);
      if (my>top && my<bottom){
        ctx.setLineDash([6,6]); ctx.strokeStyle='#9ca3af';
        ctx.beginPath(); ctx.moveTo(left, my); ctx.lineTo(right, my); ctx.stroke(); ctx.setLineDash([]);
      }
    }

    if (opts && opts.labels){
      const mode = (opts.labels === true) ? 'both' : String(opts.labels);
      ctx.font = '12px Inter, system-ui, -apple-system, Segoe UI, Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = opts.labelColor || '#111827';

      bars.forEach(b=>{
        const cx = x.getPixelForValue(b.idx);
        const yStart = y.getPixelForValue(b.start);
        const yEnd   = y.getPixelForValue(b.end);
        const yTop   = Math.min(yStart, yEnd);
        const yBot   = Math.max(yStart, yEnd);

        const topY = Math.max(top + 10, yTop - 6);
        const botY = Math.min(bottom - 4, yBot + 12);
        const cxClamped = Math.min(Math.max(cx, left+10), right-10);

        if (mode === 'end'  || mode === 'both')  ctx.fillText(fmtHM(b.end),   cxClamped, topY);
        if (mode === 'start'|| mode === 'both')  ctx.fillText(fmtHM(b.start), cxClamped, botY);
      });
    }
    ctx.restore();
  }
};
Chart.register(candlesPlugin);

const p1LabelPlugin = {
  id: 'p1LabelPlugin',
  afterDatasetsDraw(chart, args, opts){
    if (!opts || opts.enabled !== true) return;
    if (chart.config.type !== 'bar') return;
    const {ctx, chartArea:{top,left,right}, scales:{y}} = chart;
    const meta = chart.getDatasetMeta(0);
    const data = chart.data.datasets[0]?.data || [];
    if (!meta || !meta.data) return;

    ctx.save();
    ctx.font = '12px Inter, system-ui, -apple-system, Segoe UI, Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillStyle = opts?.color || '#111827';
    for (let i=0;i<meta.data.length;i++){
      const el = meta.data[i];
      const val = Number(data[i] || 0);
      if (!el || !isFinite(val) || val<=0) continue;
      const {x, y:py} = el.getProps(['x','y'], true);
      const yTop = Math.max(top + 4, py - 6);
      const txt = fmtDurHMS(val);
      const xClamped = Math.min(Math.max(x, left+8), right-8);
      ctx.fillText(txt, xClamped, yTop);
    }
    ctx.restore();
  }
};
Chart.register(p1LabelPlugin);

const timelinePlugin = {
  id:'timelinePlugin',
  afterDraw(chart, args, opts){
    const {ctx, chartArea:{top,bottom,left,right}, scales:{x}} = chart;
    const segs = chart.$timelineSegments || [];
    const midY = (top+bottom)/2; const barH = Math.min(26, (bottom-top)*0.32);
    ctx.save();
    segs.forEach(s=>{
      const x1 = x.getPixelForValue(s.start), x2 = x.getPixelForValue(s.end);
      if (Number.isNaN(x1)||Number.isNaN(x2)) return;
      const a=Math.max(left,Math.min(right,x1)); const b=Math.max(left,Math.min(right,x2));
      if (b<=left||a>=right) return;
      ctx.fillStyle = s.color; ctx.fillRect(a, midY-barH/2, Math.max(1,b-a), barH);
    });
    if (opts && opts.midnight){
      const xm = x.getPixelForValue(opts.midnight);
      if (xm>left && xm<right){ ctx.strokeStyle='#9ca3af'; ctx.setLineDash([6,6]); ctx.beginPath(); ctx.moveTo(xm, top); ctx.lineTo(xm, bottom); ctx.stroke(); ctx.setLineDash([]); }
    }
    ctx.restore();
  }
};
Chart.register(timelinePlugin);

/********************** HELPERS **********************/
function toYMDLocal(d=new Date()){ const tz=d.getTimezoneOffset(); return new Date(d.getTime()-tz*60000).toISOString().slice(0,10); }
function ymOf(ymd){ return ymd.slice(0,7); }
function parseLocal(s){ return s.length===10 ? new Date(s+'T00:00:00') : new Date(s.replace(' ','T')); }
function pad2(n){ return String(n).padStart(2,'0'); }
function imagePathFor(code){
  const name=(MACHINE_META[code]?.name)||code;
  const m=String(name).match(/\d+/); const n=m?m[0]:({CNC1:14,CNC2:15,CNC3:16,CNC4:17}[code]);
  return `${SERVER_ORIGIN}/assets/machines/${encodeURIComponent(`OKUMA CNC ${n||14}.jpg`)}`;
}
async function fetchJSON(path){
  const url = path.startsWith('http')? path : `${API_BASE}${path}`;
  const headers = { 'Content-Type':'application/json' };
  if (API_KEY) headers['x-api-key'] = API_KEY;
  const res = await fetch(url, { headers, cache:'no-store' });
  if(!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json();
}
function nextYMD(ymd){ const d=parseLocal(ymd); d.setDate(d.getDate()+1); return toYMDLocal(d); }
function fmtHMS(ms){ const d=new Date(ms); return `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`; }
function fmtHM(ms){ const d=new Date(ms); return `${pad2(d.getHours())}:${pad2(d.getMinutes())}`; }
function prettyYMD(ymd){ return new Date(ymd+'T00:00:00').toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }); }
function updateMainHero(){ el('mainDateHero').textContent = prettyYMD(mainDate.value); }
function fmtDurHM(sec){ let s = Math.max(0, Math.round(sec||0)); const hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60); return `${pad2(hh)}:${pad2(mm)}`; }
function fmtDurHMS(sec){ let s = Math.max(0, Math.round(sec||0)); const hh=Math.floor(s/3600), mm=Math.floor((s%3600)/60), ss=s%60; return `${pad2(hh)}:${pad2(mm)}:${pad2(ss)}`; }

function dynamicYFromCandles(candles, ymd){
  const { start, end } = rangeOf(ymd);
  if (!candles || candles.length === 0) return { min: start, max: end };
  const firstStart = candles[0].start;
  const lastEnd    = candles[candles.length - 1].end;
  const now = Date.now();
  const inTodayWin = (now >= start && now <= end);
  let min = Math.max(start, firstStart);
  let max = Math.min(end, inTodayWin ? Math.max(lastEnd, now) : lastEnd);
  const MIN_SPAN = 60 * 1000;
  if (max - min < MIN_SPAN) { const mid=(min+max)/2; min=Math.max(start,mid-MIN_SPAN/2); max=Math.min(end,mid+MIN_SPAN/2); }
  return { min, max };
}
function applyAdaptiveTimeUnits(chart, spanMs){
  const ONE_H = 3600*1000, opts = chart.options.scales.y.time;
  if (spanMs <= 1*ONE_H){ opts.unit='minute'; opts.stepSize=5; }
  else if (spanMs <= 3*ONE_H){ opts.unit='minute'; opts.stepSize=10; }
  else { opts.unit='hour'; opts.stepSize=1; }
}

function cleanMergeTimeline(rows, ymd, noiseMs = P3_NOISE_MS, mergeGapMs = P3_MERGE_GAP_MS){
  const { start, end } = rangeOf(ymd);
  const now = Date.now();
  let segs = (rows||[]).map(r => {
    const c = (r.color||'').toLowerCase();
    let a = parseLocal(r.start_time).getTime();
    let b = r.end_time ? parseLocal(r.end_time).getTime() : Math.min(now, end);
    if (b <= start || a >= end) return null;
    a = Math.max(a, start); b = Math.min(b, end);
    return { c, a, b };
  }).filter(Boolean);
  segs = segs.filter(s => (s.b - s.a) > noiseMs);
  segs = segs.filter(s => !(s.c === 'gray' && (s.b - s.a) < mergeGapMs));
  segs.sort((p,q)=> (p.a - q.a) || (p.b - q.b));
  const out = [];
  for (const s of segs){
    const last = out[out.length - 1];
    if (last && last.c === s.c && (s.a - last.b) <= mergeGapMs){ last.b = Math.max(last.b, s.b); }
    else { out.push({...s}); }
  }
  return out;
}

/********************** API WRAPPERS **********************/
async function apiMachines(){
  try{
    const rows = await fetchJSON('/machines');
    MACHINES = rows.map(r => r.code || r.CODE).filter(Boolean);
    MACHINE_META = {}; rows.forEach(r => { const code=r.code||r.CODE; MACHINE_META[code]={code, name:r.name||r.NAME||code}; });
    if (!ACTIVE) ACTIVE = MACHINES[0] || null;
  }catch{
    MACHINES = ['CNC1','CNC2','CNC3','CNC4'];
    MACHINE_META = { CNC1:{code:'CNC1',name:'OKUMA 20'}, CNC2:{code:'CNC2',name:'OKUMA 21'}, CNC3:{code:'CNC3',name:'OKUMA 22'}, CNC4:{code:'CNC4',name:'OKUMA 23'} };
    if (!ACTIVE) ACTIVE = 'CNC1';
  }
}
async function apiOverviewToday(){
  try{
    const data = await fetchJSON('/overview/today');
    // Update CURRENT_MACHINE_STATUS based on the fetched data
    const statusMap = {};
    (data.overview || []).forEach(item => {
      const code = item?.machine?.code || item?.CODE;
      const color = (item?.current?.color || 'unknown').toLowerCase();
      if (code) statusMap[code] = color;
    });
    CURRENT_MACHINE_STATUS = statusMap;
    return data;
  } catch {
    return { overview:[] };
  }
}
async function apiDailyBuckets(code, ymd){
  const rows = await fetchJSON(`/machines/${encodeURIComponent(code)}/status/by-date?date=${encodeURIComponent(ymd)}`);
  const sec = { green:0, yellow:0, red:0 ,gray:0};
  (rows||[]).forEach(r => { const c=(r.color||'').toLowerCase(); if (c in sec) sec[c]+=Number(r.seconds||0); });
  return sec;
}
async function apiMonthlySummary(code, ym) {
  try {
    return await fetchJSON(`/machines/${encodeURIComponent(code)}/status/by-month?month=${encodeURIComponent(ym)}`);
  } catch(e) {
    console.warn("Monthly API failed, falling back to daily.", e.message);
    // Fallback to old method if new API is not available
    const d0 = new Date(ym+'-01T00:00:00');
    const days = new Date(d0.getFullYear(), d0.getMonth()+1, 0).getDate();
    const promises = Array.from({length:days}, (_,i) => apiDailyBuckets(ACTIVE, `${ym}-${pad2(i+1)}`));
    const results = await Promise.all(promises);
    return results.map((data, i) => ({ date: `${ym}-${pad2(i+1)}`, ...data }));
  }
}

async function apiTimeline(code, ymd){ return await fetchJSON(`/machines/${encodeURIComponent(code)}/timeline?date=${encodeURIComponent(ymd)}`); }
async function apiTouchTimeline(code, ymd){ return await fetchJSON(`/machines/${encodeURIComponent(code)}/touch/timeline?date=${encodeURIComponent(ymd)}`); }

async function apiTimelineSpan(code, ymd, minsAfterMidnight = DAY_START.hh*60 + DAY_START.mm){
  const nd = nextYMD(ymd);
  const [today, next] = await Promise.all([apiTimeline(code, ymd), apiTimeline(code, nd)]);
  const nextMid = parseLocal(nd+'T00:00:00'), cutoff=new Date(nextMid.getTime()+minsAfterMidnight*60000);
  const nextSlice = (next||[]).filter(r => { const s=parseLocal(r.start_time); return s>=nextMid && s<cutoff; });
  return [...(today||[]), ...nextSlice];
}
async function apiTouchTimelineSpan(code, ymd, minsAfterMidnight = DAY_START.hh*60 + DAY_START.mm){
  const nd = nextYMD(ymd);
  const [today, next] = await Promise.all([apiTouchTimeline(code, ymd), apiTouchTimeline(code, nd)]);
  const nextMid = parseLocal(nd+'T00:00:00'), cutoff=new Date(nextMid.getTime()+minsAfterMidnight*60000);
  const nextSlice = (next||[]).filter(r => { const s=parseLocal(r.start_time); return s>=nextMid && s<cutoff; });
  return [...(today||[]), ...nextSlice];
}

/********************** TABS & UI **********************/
function renderTabs(statusByCode={}){
  tabsEl.innerHTML='';
  MACHINES.forEach(code => {
    const btn = document.createElement('button');
    btn.className = 'tab'+(code===ACTIVE?' active':'');
    btn.innerHTML = `<span class="title">${MACHINE_META[code]?.name||code}</span><span class="dot"></span>`;
    btn.onclick = () => { ACTIVE=code; refreshAll(); };
    const dot = btn.querySelector('.dot');
    dot.style.background = COLORS[statusByCode[code]||'unknown'];
    tabsEl.appendChild(btn);
  });
}
function markActiveTab(){
  [...tabsEl.children].forEach(x=>x.classList.remove('active'));
  const i=MACHINES.indexOf(ACTIVE); if(i>=0) tabsEl.children[i].classList.add('active');
}
function updateUIState(){
    markActiveTab();
    previewCap.textContent = MACHINE_META[ACTIVE]?.name || ACTIVE;
    previewImg.onerror = ()=>{ previewCap.textContent='No photo'; };
    previewImg.src = imagePathFor(ACTIVE);
    
    // Update main header with machine name and status dot
    contextTitleEl.textContent = `${MACHINE_META[ACTIVE]?.name||ACTIVE}`;
    contextStatusDotEl.style.background = COLORS[CURRENT_MACHINE_STATUS[ACTIVE] || 'unknown'];
    updateMainHero();
}

/********************** PANEL 1 – daily bar **********************/
let p1Chart;
async function drawP1(){
  try {
    const ymd = el('p1Date').value;
    const sec = await apiDailyBuckets(ACTIVE, ymd);
    p1Chart.data.datasets[0].data = [sec.green, sec.yellow, sec.red, sec.gray];
    p1Chart.update();
  } catch(e) { console.error("P1 Error:", e); }
}

/********************** PANEL 2 – monthly active-only bar **********************/
let p2Chart;
async function drawP2(){
  try {
    const ym = el('p2Month').value;
    const d0 = new Date(ym+'-01T00:00:00');
    const daysInMonth = new Date(d0.getFullYear(), d0.getMonth()+1, 0).getDate();
    const labels = Array.from({length:daysInMonth}, (_,i)=> String(i+1));
    p2Chart.data.labels = labels;

    const monthlyData = await apiMonthlySummary(ACTIVE, ym);
    const results = Array(daysInMonth).fill({green:0,yellow:0,red:0,gray:0});
    monthlyData.forEach(dayData => {
        const dayIndex = parseInt(dayData.date.slice(8,10), 10) - 1;
        if (dayIndex >= 0 && dayIndex < daysInMonth) {
            results[dayIndex] = dayData;
        }
    });

    if (P2_MODE === 'single'){
      const secs = results.map(sec => (sec[P2_STATUS]||0));
      p2Chart.data.datasets = [{ label: `${STATUS_LABEL[P2_STATUS]} time`, data: secs, backgroundColor: COLORS[P2_STATUS] }];
      p2Chart.options.scales.x.stacked = false;
      p2Chart.options.scales.y.stacked = false;
      p2Chart.options.plugins.legend.display = false;
    } else {
      const g = results.map(s=>s.green||0), y = results.map(s=>s.yellow||0), r = results.map(s=>s.red||0), o = results.map(s=>s.gray||0);
      p2Chart.data.datasets = [
        { label:'Run',   data:g, backgroundColor:COLORS.green, stack:'daily' },
        { label:'Wait',  data:y, backgroundColor:COLORS.yellow, stack:'daily' },
        { label:'Alarm', data:r, backgroundColor:COLORS.red,    stack:'daily' },
        { label:'Off/Sleep', data:o, backgroundColor:COLORS.gray, stack:'daily' }
      ];
      p2Chart.options.scales.x.stacked = true;
      p2Chart.options.scales.y.stacked = true;
      p2Chart.options.plugins.legend.display = true;
    }
    p2Chart.update();
  } catch(e) { console.error("P2 Error:", e); }
}

/********************** PANEL 3 – TIMELINE **********************/
let p3Chart, p3Timer=null;
function rangeOf(ymd){
  const d=parseLocal(ymd), s=new Date(d.getFullYear(),d.getMonth(),d.getDate(),DAY_START.hh,DAY_START.mm,0).getTime();
  const e=new Date(d.getFullYear(),d.getMonth(),d.getDate()+1,DAY_START.hh,DAY_START.mm,0).getTime();
  const m=new Date(d.getFullYear(),d.getMonth(),d.getDate()+1,0,0,0).getTime();
  return {start:s,end:e,midnight:m};
}
async function drawP3Once(){
  try {
    const ymd = el('p3Date').value;
    const tl = await apiTimelineSpan(ACTIVE, ymd);
    const { midnight } = rangeOf(ymd);
    const merged = cleanMergeTimeline(tl, ymd);
    const candles = merged.map((s, i) => ({ idx:i+1, start:s.a, end:s.b, color:COLORS[s.c]||COLORS.gray }));
    const dyn = dynamicYFromCandles(candles, ymd);
    p3Chart.options.scales.y.min = dyn.min; p3Chart.options.scales.y.max = dyn.max;
    applyAdaptiveTimeUnits(p3Chart, dyn.max - dyn.min);
    p3Chart.options.scales.x.max = candles.length + 1;
    p3Chart.options.plugins.candlesPlugin.midnight = midnight;
    p3Chart.$candles = candles;
    p3Chart.update();
  } catch(e) { console.error("P3 Error:", e); }
}
function startP3Auto(){ stopP3Auto(); drawP3Once(); const {start,end}=rangeOf(el('p3Date').value), n=Date.now(); if(n>=start&&n<=end)p3Timer=setInterval(drawP3Once,STEP_REFRESH_MS); }
function stopP3Auto(){ if (p3Timer) clearInterval(p3Timer), p3Timer=null; }

/********************** PANEL 4 – WORKER STATUS **********************/
let p4Chart, p4Timer=null;
function buildTouchCandles(rows, ymd){
  const {start,end}=rangeOf(ymd), now=Date.now(), segs=[];
  (rows||[]).forEach(r=>{
    let a=parseLocal(r.start_time).getTime(), b=r.end_time?parseLocal(r.end_time).getTime():Math.min(now,end);
    if(b<=start||a>=end)return;
    a=Math.max(a,start); b=Math.min(b,end);
    const color=(TOUCH[r.status_id]?.color)||'#9ca3af';
    segs.push({start:a,end:b,color,emp_id:r.emp_id});
  });
  segs.sort((p,q)=>p.start-q.start);
  return segs.map((s,i)=>({idx:i+1,start:s.start,end:s.end,color:s.color,emp_id:s.emp_id}));
}
async function drawP4Once(){
  try {
    const ymd = el('p4Date').value;
    const tl  = await apiTouchTimelineSpan(ACTIVE, ymd);
    const { midnight } = rangeOf(ymd);
    const candles = buildTouchCandles(tl, ymd);
    const dyn = dynamicYFromCandles(candles, ymd);
    p4Chart.options.scales.y.min = dyn.min; p4Chart.options.scales.y.max = dyn.max;
    applyAdaptiveTimeUnits(p4Chart, dyn.max - dyn.min);
    p4Chart.options.scales.x.max = candles.length + 1;
    p4Chart.options.plugins.candlesPlugin.midnight = midnight;
    p4Chart.$candles = candles;
    p4Chart.update();
  } catch(e) { console.error("P4 Error:", e); }
}
function startP4Auto(){ stopP4Auto(); drawP4Once(); const {start,end}=rangeOf(el('p4Date').value), n=Date.now(); if(n>=start&&n<=end)p4Timer=setInterval(drawP4Once,STEP_REFRESH_MS); }
function stopP4Auto(){ if (p4Timer) clearInterval(p4Timer), p4Timer=null; }

/********************** LIVE REFRESH & SYNC **********************/
let liveTimer = null;
async function startLiveLoops(){
  stopLiveLoops();
  startP3Auto();
  startP4Auto();

  liveTimer = setInterval(async ()=>{
    try {
      await apiOverviewToday(); // This updates CURRENT_MACHINE_STATUS
      renderTabs(CURRENT_MACHINE_STATUS); // Re-render tabs with updated status
      updateUIState(); // Update main header status dot

    } catch (e) {
      console.error("Live loop error:", e);
    }
    const ymd = mainDate.value, {start,end}=rangeOf(ymd), now=Date.now();
    if (now >= start && now <= end) drawP1();
    if (AUTO_ROLL_MAINDATE && now > end) { const nd=toYMDLocal(new Date()); if (mainDate.value!==nd){ setMainDate(nd); } }
  },LIVE_MS);
}
function stopLiveLoops(){ if (liveTimer) { clearInterval(liveTimer); liveTimer = null; } }

function setMainDate(ymd, sourceEl = null) {
    if (sourceEl !== mainDate) mainDate.value = ymd;
    if (sourceEl !== el('p1Date')) el('p1Date').value = ymd;
    if (sourceEl !== el('p3Date')) el('p3Date').value = ymd;
    if (sourceEl !== el('p4Date')) el('p4Date').value = ymd;

    const newYm = ymOf(ymd);
    if (el('p2Month').value !== newYm) el('p2Month').value = newYm;

    refreshAll();
}

/********************** BOOTSTRAP **********************/
function wireEventListeners(){
  el('hamburger-close').addEventListener('click', ()=>document.body.classList.add('sidebar-collapsed'));
  el('hamburger-open').addEventListener('click', ()=>document.body.classList.remove('sidebar-collapsed'));

  mainDate.addEventListener('change', (e)=> setMainDate(e.target.value, mainDate));
  el('p1Date').addEventListener('change', (e)=> setMainDate(e.target.value, el('p1Date')));
  el('p3Date').addEventListener('change', (e)=> setMainDate(e.target.value, el('p3Date')));
  el('p4Date').addEventListener('change', (e)=> setMainDate(e.target.value, el('p4Date')));
  el('p2Month').addEventListener('change', ()=> drawP2());

  el('p2Status').addEventListener('click', (e)=>{
    const btn = e.target.closest('button.seg'); if(!btn) return;
    [...el('p2Status').querySelectorAll('.seg')].forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    if (btn.dataset.mode === 'summary'){
      P2_MODE = 'summary';
      el('p2Title').textContent = 'Monthly status overview (stacked)';
      el('p2LegendText').textContent = 'Daily stacked ratio';
      el('p2LegendChip').style.background = `linear-gradient(90deg,${COLORS.green},${COLORS.yellow},${COLORS.red},${COLORS.gray})`;
    } else {
      P2_MODE = 'single'; P2_STATUS = btn.dataset.color;
      el('p2Title').textContent = `Monthly runtime overview (${STATUS_LABEL[P2_STATUS]})`;
      el('p2LegendText').textContent = `${STATUS_LABEL[P2_STATUS]} time per day`;
      el('p2LegendChip').style.background = COLORS[P2_STATUS];
    }
    drawP2();
  });
  
  const tip3 = el('p3Tip');
  (function attachP3Hover(){
    const c=p3Chart.canvas, hide=()=>tip3.classList.add('hidden'), show=(x,y,t)=>{ tip3.textContent=t;tip3.style.left=(x+12)+'px';tip3.style.top=(y+12)+'px';tip3.classList.remove('hidden'); };
    c.addEventListener('mouseleave', hide);
    c.addEventListener('mousemove', (ev)=>{
      const r=c.getBoundingClientRect(),xpx=ev.clientX-r.left,ypx=ev.clientY-r.top, {chartArea:{top,bottom,left,right},scales:{x,y}}=p3Chart;
      if (xpx<left||xpx>right||ypx<top||ypx>bottom) return hide();
      const bars=p3Chart.$candles||[]; if(!bars.length)return hide();
      const colW=Math.max(8,((right-left)/Math.max(1,bars.length+2))*0.6); let hit=null;
      for(const b of bars){ const cx=x.getPixelForValue(b.idx),y1=y.getPixelForValue(b.start),y2=y.getPixelForValue(b.end),ya=Math.min(y1,y2),yb=Math.max(y1,y2); if(xpx>=cx-colW/2&&xpx<=cx+colW/2&&ypx>=ya&&ypx<=yb){hit=b;break;} }
      if(!hit)return hide(); show(xpx,ypx,`${fmtHMS(hit.start)} → ${fmtHMS(hit.end)}`);
    });
  })();
  
  const tip4 = el('p4Tip');
  (function attachP4Hover(){
    const c=p4Chart.canvas, hide=()=>tip4.classList.add('hidden'), show=(x,y,t)=>{ tip4.textContent=t;tip4.style.left=(x+12)+'px';tip4.style.top=(y+12)+'px';tip4.classList.remove('hidden'); };
    c.addEventListener('mouseleave', hide);
    c.addEventListener('mousemove', (ev)=>{
      const r=c.getBoundingClientRect(),xpx=ev.clientX-r.left,ypx=ev.clientY-r.top, {chartArea:{top,bottom,left,right},scales:{x,y}}=p4Chart;
      if (xpx<left||xpx>right||ypx<top||ypx>bottom)return hide();
      const bars=p4Chart.$candles||[]; if(!bars.length)return hide();
      const colW=Math.max(8,((right-left)/Math.max(1,bars.length+2))*0.6); let hit=null;
      for(const b of bars){ const cx=x.getPixelForValue(b.idx),y1=y.getPixelForValue(b.start),y2=y.getPixelForValue(b.end),ya=Math.min(y1,y2),yb=Math.max(y1,y2); if(xpx>=cx-colW/2&&xpx<=cx+colW/2&&ypx>=ya&&ypx<=yb){hit=b;break;} }
      if(!hit)return hide(); show(xpx,ypx,`${fmtHMS(hit.start)} → ${fmtHMS(hit.end)} • emp ${hit.emp_id}`);
    });
  })();
}

(async function boot(){
  const today = toYMDLocal(new Date());
  mainDate.value = today; el('p1Date').value = today;
  el('p3Date').value = today; el('p4Date').value = today;
  el('p2Month').value = ymOf(today);

  p1Chart = new Chart(el('p1Chart').getContext('2d'),{
    type:'bar', data:{ labels:[LABEL.green,LABEL.yellow,LABEL.red,LABEL.gray], datasets:[{label:'Time',data:[0,0,0,0],backgroundColor:[COLORS.green,COLORS.yellow,COLORS.red,COLORS.gray],borderWidth:0,categoryPercentage:0.6,barPercentage:0.7}] },
    options:{ responsive:true,maintainAspectRatio:false,layout:{padding:{top:18}},scales:{y:{beginAtZero:true,min:0,max:24*3600,ticks:{stepSize:2*3600,callback:(v)=>fmtDurHM(v)},title:{display:true,text:'Time'}}},plugins:{legend:{display:false},p1LabelPlugin:{enabled:true},tooltip:{callbacks:{label:(c)=>`${c.dataset.label}: ${fmtDurHMS(c.parsed.y)}`}}}}
  });

  p2Chart = new Chart(el('p2Chart').getContext('2d'),{
    type:'bar', data:{ labels:[], datasets:[{ label:'Active time per day', data:[], backgroundColor:COLORS.green }] },
    options:{ responsive:true,maintainAspectRatio:false,scales:{y:{beginAtZero:true,min:0,max:24*3600,ticks:{stepSize:2*3600,callback:(v)=>fmtDurHM(v)},title:{display:true,text:'Time'}},x:{title:{display:true,text:'Day of month'}}},plugins:{legend:{display:false},tooltip:{callbacks:{label:(c)=>`${c.dataset.label}: ${fmtDurHMS(c.parsed.y)}`}}}}
  });

  p3Chart = new Chart(el('p3Chart').getContext('2d'),{
    type:'scatter', data:{datasets:[{data:[]}]}, options:{responsive:true,maintainAspectRatio:false,parsing:false,layout:{padding:{top:16,bottom:16}},scales:{y:{type:'time',time:{unit:'hour',displayFormats:{hour:'HH:mm'}}},x:{type:'linear',min:0,ticks:{stepSize:1,precision:0}}},plugins:{legend:{display:false},tooltip:{enabled:false},candlesPlugin:{midnight:null,labels:false}}}
  });
  
  p4Chart = new Chart(el('p4Chart').getContext('2d'),{
    type:'scatter', data:{datasets:[{data:[]}]}, options:{responsive:true,maintainAspectRatio:false,parsing:false,scales:{y:{type:'time',time:{unit:'hour',displayFormats:{hour:'HH:mm'}}},x:{type:'linear',min:0,ticks:{stepSize:1,precision:0}}},plugins:{legend:{display:false},tooltip:{enabled:false},candlesPlugin:{midnight:null,labels:'end'}}}
  });

  wireEventListeners();

  await apiMachines();
  await apiOverviewToday(); // Fetch initial status
  renderTabs(CURRENT_MACHINE_STATUS);
  
  await refreshAll();
})();

async function refreshAll(){
  globalErr.textContent='';
  try{
    updateUIState(); // This will now update the main header's status dot
    await Promise.all([
        drawP1(),
        drawP2(),
    ]);
    startLiveLoops();
  }catch(e){ globalErr.textContent = e.message||String(e); }
}
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OKUMA CNC Dashboard – Rework</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net"/>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
<style>
  :root{
    --bg:#f6f7fb; --panel:#fff; --muted:#6b7280; --ring:#e5e7eb;
    --green:#0D8C25; --yellow:#E69400; --red:#EB0000; --grey:#9ca3af;
  }
  *{box-sizing:border-box}
  /* Full-viewport layout: sticky sidebar + no body scroll */
  body{
    margin:0;font-family:Inter,system-ui,Segoe UI,Arial,sans-serif;
    background:var(--bg);color:#111827;
    min-height:100vh; display:grid; grid-template-columns:280px 1fr;
    overflow:hidden;
  }
  /* SIDEBAR (sticky) */
  .sidebar{
    position:sticky; top:0; height:100vh; width:280px; min-width:240px;
    background:#1f2937;color:#fff;display:flex;flex-direction:column;
    padding:18px 14px;gap:14px
  }
  .brand{font-weight:800;letter-spacing:.3px}
  .tabs{display:flex;flex-direction:column;gap:10px;margin-top:8px;overflow:auto;padding-right:4px}
  .tab{display:flex;align-items:center;justify-content:space-between;gap:10px;background:#374151;border:none;color:#fff;padding:12px;border-radius:14px;cursor:pointer;transition:background .2s}
  .tab:hover{background:#4b5563}
  .tab.active{background:#111827;box-shadow:0 0 0 2px #6b7280 inset}
  .tab .title{flex:1;text-align:left}
  .dot{width:14px;height:14px;border-radius:50%;background:#9ca3af;flex:0 0 auto}
  .preview{margin-top:auto;background:#0b1220;border-radius:12px;padding:10px;text-align:center}
  .preview img{width:100%;display:block;border-radius:10px}
  .preview .cap{color:#d1d5db;font-size:14px;margin-top:6px}

  /* MAIN (fills viewport; two rows of charts that fit without page scroll) */
  .main{height:100vh;display:grid;grid-template-rows:auto 1fr 1fr;gap:10px;padding:12px;overflow:hidden}
  .panel{background:var(--panel);border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.06);padding:12px;min-height:0;display:flex;flex-direction:column}
  .panel-header{display:flex;align-items:center;gap:12px;justify-content:space-between;margin-bottom:6px}
  .title{font-weight:700}
  .muted{color:var(--muted);font-size:12px}
  .err{color:#b91c1c;font-size:12px}

  .topbar,.grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;min-height:0}
  @media (max-width: 1200px){
    .topbar{grid-template-columns:1fr}
    .grid{grid-template-columns:1fr}
    .main{grid-template-rows:auto 1fr 1fr}
  }

  .chart-wrap{position:relative;flex:1;min-height:0}
  .picker{display:flex;align-items:center;gap:8px}
  .picker input[type="date"], .picker input[type="month"]{padding:8px 10px;border:1px solid #d1d5db;border-radius:10px}
  .legend-chip{display:inline-flex;align-items:center;gap:6px;margin-right:10px}
  .chip{width:10px;height:10px;border-radius:3px;display:inline-block}
  /* segmented buttons (Panel 2) */
/* segmented buttons (Panel 2) */
  .seg-btns{display:flex;gap:6px;flex-wrap:wrap}
  .seg-btns .seg{border:1px solid #d1d5db;background:#fff;padding:6px 10px;border-radius:8px;cursor:pointer;font-size:12px}
  .seg-btns .seg.active{background:#111827;color:#fff;border-color:#111827}

  /* compact horizontal legend row (Panel 3, used later) */
  .legend-row{display:flex;gap:14px;flex-wrap:wrap;margin:4px 0 6px}
  .date-hero{
    display:flex; align-items:center; justify-content:center;
    text-align:center; font-weight:800;
    font-size:clamp(18px, 2.2vw, 28px);
    letter-spacing:.2px; padding:6px 0 2px;
  }
  .tip{position:absolute; z-index:10; pointer-events:none;
     background:rgba(17,24,39,.92); color:#fff;
     border-radius:8px; padding:6px 8px; font-size:12px;
     box-shadow:0 6px 18px rgba(0,0,0,.2)}
  .tip.hidden{display:none}
  /* compact panel chrome just for the top bar */
  .panel.compact{ padding:8px 10px; }
  .panel.compact .panel-header{ margin-bottom:4px; }

  /* put the hero inside the header without affecting layout height */
  .hero-header{ position:relative; padding:6px 0; min-height:44px; }
  .hero-header .title,
  .hero-header .picker{ position:relative; z-index:1; }  /* stay clickable */
  .date-hero.in-header{
    position:absolute; left:0; right:0; top:50%;
    transform:translateY(-50%);
    text-align:center; pointer-events:none;
    font-weight:800;
    font-size:clamp(16px, 2.0vw, 24px);  /* a touch smaller than before */
    letter-spacing:.2px;
  }

  /* tiny trims to inputs in the top bar */
  .panel.compact .picker input[type="date"]{ padding:6px 8px; }

  /* auto-hide empty rows to save vertical space */
  .err:empty, .muted:empty{ display:none; }


</style>
</head>
<body>
  <aside class="sidebar">
    <div class="brand">CNC Machine Dashboard</div>
    <div id="machineTabs" class="tabs"></div>

    <div class="preview" id="machinePreview">
      <img id="machinePreviewImg" alt="Machine photo" />
      <div class="cap" id="machinePreviewCaption">Machine photo</div>
    </div>
  </aside>

  <main class="main">

    <!-- MAIN DATE (drives all pickers) -->
    <section class="panel compact" id="mainDatePanel">
      <div class="panel-header hero-header">
        <div class="title">Select Date</div>
        <!-- ⬇︎ move the hero INSIDE the header -->
        <div id="mainDateHero" class="date-hero in-header"></div>
        <div class="picker"><input type="date" id="mainDate" /></div>
      </div>
      <div class="muted" id="contextInfo"></div>
      <div class="err" id="globalErr"></div>
    </section>


    <section class="topbar">

      <!-- Panel 1: Machine status / day -->
      <section class="panel">
        <div class="panel-header">
          <div>
            <div class="title">Machine status / day</div>
            <div class="muted">Active = Green, Setup = Yellow, Alarm = Red</div>
          </div>
          <div class="picker"><input type="date" id="p1Date"/></div>
        </div>
        <div class="chart-wrap sm"><canvas id="p1Chart"></canvas></div>
      </section>

      <!-- Panel 2: Monthly runtime overview (Active only) -->
      <section class="panel">
        <div class="panel-header">
          <div class="title" id="p2Title">Monthly runtime overview (Active)</div>
          <div class="picker"><input type="month" id="p2Month"/></div>
        </div>

        <!-- status selector -->
        <div class="seg-btns" id="p2Status" style="margin-bottom:6px">
          <button class="seg active" data-color="green">Active</button>
          <button class="seg" data-color="yellow">Setup</button>
          <button class="seg" data-color="red">Alarm</button>
        </div>

        <div class="legend-chip">
          <span class="chip" id="p2LegendChip" style="background:var(--green)"></span>
          <span class="muted" id="p2LegendText">Active time per day</span>
        </div>

        <!-- MISSING BEFORE: add the chart canvas -->
        <div class="chart-wrap sm"><canvas id="p2Chart"></canvas></div>
      </section>
    </section>

    <section class="grid">
      <!-- Panel 3: Machine running status overtime (step) -->
      <section class="panel">
        <div class="panel-header">
          <div class="title">Machine running status over time</div>
          <div class="picker"><input type="date" id="p3Date"/></div>
        </div>
        <div class="legend-row">
          <div class="legend-chip"><span class="chip" style="background:var(--green)"></span><span class="muted">Active</span></div>
          <div class="legend-chip"><span class="chip" style="background:var(--yellow)"></span><span class="muted">Setup</span></div>
          <div class="legend-chip"><span class="chip" style="background:var(--red)"></span><span class="muted">Alarm</span></div>
          <div class="legend-chip"><span class="chip" style="background:var(--grey)"></span><span class="muted">No signal</span></div>
        </div>
        <div class="chart-wrap">
          <canvas id="p3Chart"></canvas>
          <div id="p3Tip" class="tip hidden"></div>
        </div>
        <div class="muted">Time axis pinned: 07:30 → next-day 07:30 (local).</div>
      </section>

      <!-- Panel 4: Placeholder (Setup vs Run by month) -->
      <section class="panel">
        <div class="panel-header">
          <div class="title">Monthly summary (placeholder)</div>
          <div class="picker"><input type="month" id="p4Month"/></div>
        </div>
        <div class="chart-wrap sm"><canvas id="p4Chart"></canvas></div>
      </section>
    </section>
  </main>

<script>
/********************** CONFIG **********************/
const API_BASE = 'http://192.168.0.145:3001/api';
const API_KEY  = '';
const SERVER_ORIGIN = API_BASE.replace(/\/api\/?$/, '');

const COLORS = { green:'#0D8C25', yellow:'#E69400', red:'#EB0000', grey:'#9ca3af',unknown:'#9ca3af' };
const LABEL  = { green:'Active',  yellow:'Setup',   red:'Alarm' };

const STEP_REFRESH_MS = 1000;
const DAY_START = { hh:7, mm:30 };

/********************** STATE **********************/
let MACHINES = [], MACHINE_META = {}, ACTIVE = null;

const el = (id) => document.getElementById(id);
const mainDate   = el('mainDate');
const contextInfo= el('contextInfo');
const globalErr  = el('globalErr');
const tabsEl     = el('machineTabs');
const previewImg = el('machinePreviewImg');
const previewCap = el('machinePreviewCaption');

let P2_STATUS = 'green';  // 'green' | 'yellow' | 'red'
const STATUS_LABEL = { green:'Active', yellow:'Setup', red:'Alarm' };

/********************** PLUGINS **********************/

const candlesPlugin = {
  id:'candlesPlugin',
  afterDraw(chart, args, opts){
    const {ctx, chartArea:{top,bottom,left,right}, scales:{x,y}} = chart;
    const bars = chart.$candles || [];
    const colW = Math.max(8, ((right-left)/Math.max(1, bars.length+2)) * 0.6);

    ctx.save();
    bars.forEach(b=>{
      const cx = x.getPixelForValue(b.idx);
      const y1 = y.getPixelForValue(b.start);
      const y2 = y.getPixelForValue(b.end);
      const a = Math.min(y1,y2), h = Math.abs(y2-y1);
      ctx.fillStyle = b.color;
      ctx.fillRect(cx - colW/2, a, colW, h);
    });

    // midnight line (horizontal, at 00:00 inside the 07:30→07:30 window)
    if (opts && opts.midnight){
      const my = y.getPixelForValue(opts.midnight);
      if (my>top && my<bottom){
        ctx.setLineDash([6,6]); ctx.strokeStyle='#9ca3af';
        ctx.beginPath(); ctx.moveTo(left, my); ctx.lineTo(right, my); ctx.stroke(); ctx.setLineDash([]);
      }
    }
    ctx.restore();
  }
};
Chart.register(candlesPlugin);


/********************** HELPERS **********************/
function toYMDLocal(d=new Date()){ const tz=d.getTimezoneOffset(); return new Date(d.getTime()-tz*60000).toISOString().slice(0,10); }
function ymOf(ymd){ return ymd.slice(0,7); }
function parseLocal(s){ return s.length===10 ? new Date(s+'T00:00:00') : new Date(s.replace(' ','T')); }
function pad2(n){ return String(n).padStart(2,'0'); }
function imagePathFor(code){
  const name=(MACHINE_META[code]?.name)||code;
  const m=String(name).match(/\d+/); const n=m?m[0]:({CNC1:14,CNC2:15,CNC3:16,CNC4:17}[code]);
  return `${SERVER_ORIGIN}/assets/machines/${encodeURIComponent(`OKUMA CNC ${n||14}.jpg`)}`;
}
async function fetchJSON(path){
  const url = path.startsWith('http')? path : `${API_BASE}${path}`;
  const headers = { 'Content-Type':'application/json' };
  if (API_KEY) headers['x-api-key'] = API_KEY;
  const res = await fetch(url, { headers, cache:'no-store' });
  if(!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.json();
}

/* Get YYYY-MM-DD of the next day */
function nextYMD(ymd){
  const d = parseLocal(ymd); d.setDate(d.getDate()+1);
  return toYMDLocal(d);
}

/* Fetch [main-day timeline] + [next-day timeline], but keep only 00:00 → DAY_START slice of the next day */
async function apiTimelineSpan(code, ymd, minsAfterMidnight = DAY_START.hh*60 + DAY_START.mm /* 450 */){
  const nd = nextYMD(ymd);                               // YYYY-MM-DD (next day)
  const [today, next] = await Promise.all([
    apiTimeline(code, ymd),
    apiTimeline(code, nd)
  ]);

  const nextMid = parseLocal(nd + 'T00:00:00');
  const cutoff  = new Date(nextMid.getTime() + minsAfterMidnight*60000);

  // keep only intervals that START on/after midnight of next day
  const nextSlice = (next||[]).filter(r => {
    const s = parseLocal(r.start_time);
    return s >= nextMid && s < cutoff;
  });

  return [...(today||[]), ...nextSlice];
}
function fmtHMS(ms){
  const d = new Date(ms);
  const hh = String(d.getHours()).padStart(2,'0');
  const mm = String(d.getMinutes()).padStart(2,'0');
  const ss = String(d.getSeconds()).padStart(2,'0');
  return `${hh}:${mm}:${ss}`;
}

function prettyYMD(ymd){
  // keep your chosen format; tweak if you want localized text
  return ymd; // e.g. new Date(ymd).toLocaleDateString()
}
function updateMainHero(){ el('mainDateHero').textContent = prettyYMD(mainDate.value); }

function fmtDurHM(sec){
  let s = Math.max(0, Math.round(sec||0));
  const hh = Math.floor(s/3600);
  const mm = Math.floor((s%3600)/60);
  return `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}`;
}
function fmtDurHMS(sec){
  let s = Math.max(0, Math.round(sec||0));
  const hh = Math.floor(s/3600);
  const mm = Math.floor((s%3600)/60);
  const ss = s % 60;
  return `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
}


/********************** API WRAPPERS **********************/
async function apiMachines(){
  try{
    const rows = await fetchJSON('/machines');
    MACHINES = rows.map(r => r.code || r.CODE).filter(Boolean);
    MACHINE_META = {}; rows.forEach(r => { const code=r.code||r.CODE; MACHINE_META[code]={code, name:r.name||r.NAME||code}; });
    if (!ACTIVE) ACTIVE = MACHINES[0] || null;
  }catch{
    MACHINES = ['CNC1','CNC2','CNC3','CNC4'];
    MACHINE_META = { CNC1:{code:'CNC1',name:'OKUMA 20'}, CNC2:{code:'CNC2',name:'OKUMA 21'}, CNC3:{code:'CNC3',name:'OKUMA 22'}, CNC4:{code:'CNC4',name:'OKUMA 23'} };
    if (!ACTIVE) ACTIVE = 'CNC1';
  }
}
async function apiOverviewToday(){ try{ return await fetchJSON('/overview/today'); } catch { return { overview:[] }; } }
async function apiDailyBuckets(code, ymd){
  const rows = await fetchJSON(`/machines/${encodeURIComponent(code)}/status/by-date?date=${encodeURIComponent(ymd)}`);
  const sec = { green:0, yellow:0, red:0 };
  (rows||[]).forEach(r => { const c=(r.color||'').toLowerCase(); if (c in sec) sec[c]+=Number(r.seconds||0); });
  return sec;
}
async function apiTimeline(code, ymd){
  return await fetchJSON(`/machines/${encodeURIComponent(code)}/timeline?date=${encodeURIComponent(ymd)}`);
}

/********************** TABS **********************/
function renderTabs(statusByCode={}){
  tabsEl.innerHTML='';
  MACHINES.forEach(code => {
    const btn = document.createElement('button');
    btn.className = 'tab'+(code===ACTIVE?' active':'');
    btn.innerHTML = `<span class="title">${MACHINE_META[code]?.name||code}</span><span class="dot"></span>`;
    btn.onclick = () => { ACTIVE=code; updatePreview(); refreshAll(); };
    const dot = btn.querySelector('.dot');
    dot.style.background = COLORS[statusByCode[code]||'unknown'];
    tabsEl.appendChild(btn);
  });
}
function markActiveTab(){
  [...tabsEl.children].forEach(x=>x.classList.remove('active'));
  const i=MACHINES.indexOf(ACTIVE); if(i>=0) tabsEl.children[i].classList.add('active');
}
function updatePreview(){
  markActiveTab();
  previewCap.textContent = MACHINE_META[ACTIVE]?.name || ACTIVE;
  previewImg.onerror = ()=>{ previewCap.textContent='No photo'; };
  previewImg.src = imagePathFor(ACTIVE);
}

/********************** PANEL 1 – daily bar **********************/
let p1Chart;
async function drawP1(){
  const ymd = el('p1Date').value;
  const sec = await apiDailyBuckets(ACTIVE, ymd);
  p1Chart.data.datasets[0].data = [sec.green, sec.yellow, sec.red]; // seconds
  p1Chart.update();
}

/********************** PANEL 2 – monthly active-only bar **********************/
let p2Chart;
async function drawP2(){
  const ym = el('p2Month').value; // YYYY-MM
  const d0 = new Date(ym+'-01T00:00:00');
  const days = new Date(d0.getFullYear(), d0.getMonth()+1, 0).getDate();
  const labels = Array.from({length:days}, (_,i)=> String(i+1));
  const promises = labels.map((_,i)=> apiDailyBuckets(ACTIVE, `${ym}-${pad2(i+1)}`));
  const batch=6, out=[...promises], results=[];
  while(out.length){ const part=out.splice(0,batch); const vals=await Promise.allSettled(part); results.push(...vals.map(v=> v.status==='fulfilled'? v.value : {green:0,yellow:0,red:0})); }
  const secs = results.map(sec => (sec[P2_STATUS]||0)); // keep seconds
  p2Chart.data.labels = labels;
  p2Chart.data.datasets[0].data = secs;
  p2Chart.update();
}

/********************** PANEL 3 – TIMELINE (interval) **********************/
let p3Chart, p3Timer=null;

/* Plugin draws colored intervals + midnight guide on a time x-axis */
const timelinePlugin = {
  id:'timelinePlugin',
  afterDraw(chart, args, opts){
    const {ctx, chartArea:{top,bottom,left,right}, scales:{x}} = chart;
    const segs = chart.$timelineSegments || [];
    const midY = (top+bottom)/2; const barH = Math.min(26, (bottom-top)*0.32);
    ctx.save();
    segs.forEach(s=>{
      const x1 = x.getPixelForValue(s.start), x2 = x.getPixelForValue(s.end);
      if (Number.isNaN(x1)||Number.isNaN(x2)) return;
      const a=Math.max(left,Math.min(right,x1)); const b=Math.max(left,Math.min(right,x2));
      if (b<=left||a>=right) return;
      ctx.fillStyle = s.color; ctx.fillRect(a, midY-barH/2, Math.max(1,b-a), barH);
    });
    // midnight marker between the two days
    if (opts && opts.midnight){
      const xm = x.getPixelForValue(opts.midnight);
      if (xm>left && xm<right){ ctx.strokeStyle='#9ca3af'; ctx.setLineDash([6,6]); ctx.beginPath(); ctx.moveTo(xm, top); ctx.lineTo(xm, bottom); ctx.stroke(); ctx.setLineDash([]); }
    }
    ctx.restore();
  }
};
Chart.register(timelinePlugin);

function rangeOf(ymd){
  const d = parseLocal(ymd);
  const start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), DAY_START.hh, DAY_START.mm, 0).getTime();
  const end   = new Date(d.getFullYear(), d.getMonth(), d.getDate()+1, DAY_START.hh, DAY_START.mm, 0).getTime();
  const midnight = new Date(d.getFullYear(), d.getMonth(), d.getDate()+1, 0,0,0).getTime();
  return {start,end,midnight};
}
function buildSegments(timeline, ymd){
  const {start,end} = rangeOf(ymd);
  const now = Date.now();
  const segs=[];
  (timeline||[]).forEach(r=>{
    const c=(r.color||'').toLowerCase();
    let a = parseLocal(r.start_time).getTime();
    let b = r.end_time ? parseLocal(r.end_time).getTime() : Math.min(now, end);
    if (b<=start || a>=end) return;
    a=Math.max(a,start); b=Math.min(b,end);
    segs.push({start:a,end:b,color:COLORS[c]||COLORS.grey});
  });
  segs.sort((p,q)=>p.start-q.start);
  const out=[]; let cursor=start;
  for(const s of segs){ if (s.start>cursor) out.push({start:cursor,end:s.start,color:COLORS.grey}); out.push(s); cursor=Math.max(cursor,s.end); }
  if (cursor<end) out.push({start:cursor,end:end,color:COLORS.grey});
  return out;
}
async function drawP3Once(){
  const ymd = el('p3Date').value;

  // same window logic: 07:30 → next-day 07:30, with next-day slice merged
  const tl = await apiTimelineSpan(ACTIVE, ymd);
  const {start,end,midnight} = rangeOf(ymd);

  // reuse buildSegments but drop grey fillers to show only real states
  const raw = buildSegments(tl, ymd).filter(s => s.color !== COLORS.grey);

  // index each continuous segment (1..N) for the X axis
  const candles = raw.map((s, i) => ({ idx:i+1, start:s.start, end:s.end, color:s.color }));

  // apply new axes and data
  p3Chart.options.scales.y.min = start;
  p3Chart.options.scales.y.max = end;
  p3Chart.options.scales.x.max = candles.length + 1;
  p3Chart.options.plugins.candlesPlugin.midnight = midnight;
  p3Chart.$candles = candles;
  p3Chart.update();
}


function startP3Auto(){
  stopP3Auto();
  const {start,end} = rangeOf(el('p3Date').value);
  drawP3Once();
  const now = Date.now();
  if (now>=start && now<=end) p3Timer = setInterval(drawP3Once, STEP_REFRESH_MS);
}
function stopP3Auto(){ if (p3Timer) clearInterval(p3Timer), p3Timer=null; }

/********************** PANEL 4 – placeholder **********************/
let p4Chart; function drawP4(){ p4Chart.update(); }

/********************** BOOTSTRAP **********************/
function wireP2StatusButtons(){
  const wrap = document.getElementById('p2Status');
  if (!wrap) return; // safety

  wrap.addEventListener('click', (e)=>{
    const btn = e.target.closest('button[data-color]');
    if(!btn) return;

    P2_STATUS = btn.dataset.color;
    [...wrap.querySelectorAll('.seg')].forEach(b=>b.classList.toggle('active', b===btn));

    // reflect in UI + dataset
    el('p2Title').textContent = `Monthly runtime overview (${STATUS_LABEL[P2_STATUS]})`;
    el('p2LegendText').textContent = `${STATUS_LABEL[P2_STATUS]} time per day`;
    el('p2LegendChip').style.background = COLORS[P2_STATUS];

    if (p2Chart) {
      p2Chart.data.datasets[0].label = `${STATUS_LABEL[P2_STATUS]} time per day`;
      p2Chart.data.datasets[0].backgroundColor = COLORS[P2_STATUS];
      drawP2();
    }
  });
}


(async function boot(){
  const today = toYMDLocal(new Date());
  mainDate.value = today;
  updateMainHero();
  el('p1Date').value = today;
  el('p3Date').value = today;
  el('p2Month').value = ymOf(today);
  el('p4Month').value = ymOf(today);

  p1Chart = new Chart(el('p1Chart').getContext('2d'),{
    type:'bar',
    data:{
      labels:[LABEL.green, LABEL.yellow, LABEL.red],
      datasets:[{
        label:'Time per day',            // was: 'Hours'
        data:[0,0,0],
        backgroundColor:[COLORS.green, COLORS.yellow, COLORS.red],
        borderWidth:0, categoryPercentage:0.6, barPercentage:0.7
      }]
    },
    options:{
      responsive:true, maintainAspectRatio:false,
      scales:{
        y:{
          beginAtZero:true,
          min:0,
          max:24*3600,                    // 24h in seconds
          ticks:{
            stepSize:2*3600,              // 2h grid
            callback:(v)=>fmtDurHM(v)
          },
          title:{ display:true, text:'Time' }
        }
      },
      plugins:{
        legend:{ display:false },
        tooltip:{
          callbacks:{
            label:(ctx)=> `${ctx.dataset.label}: ${fmtDurHMS(ctx.parsed.y)}`
          }
        }
      }
    }
  });


  p2Chart = new Chart(el('p2Chart').getContext('2d'),{
    type:'bar',
    data:{ labels:[], datasets:[{ label:'Active time per day', data:[], backgroundColor:COLORS.green }] },
    options:{
      responsive:true, maintainAspectRatio:false,
      scales:{
        y:{
          beginAtZero:true,
          min:0, max:24*3600,
          ticks:{ stepSize:2*3600, callback:(v)=>fmtDurHM(v) },
          title:{ display:true, text:'Time' }
        },
        x:{ title:{ display:true, text:'Day of month' } }
      },
      plugins:{
        legend:{ display:false },
        tooltip:{
          callbacks:{
            label:(ctx)=> `${ctx.dataset.label}: ${fmtDurHMS(ctx.parsed.y)}`
          }
        }
      }
    }
  });
  wireP2StatusButtons();

  /* Panel 3 base chart (rectangles painted by candlesPlugin) */
  p3Chart = new Chart(el('p3Chart').getContext('2d'),{
    type:'scatter',
    data:{ datasets:[{ data:[] }] },
    options:{ responsive:true, maintainAspectRatio:false, parsing:false,
      scales:{
        y:{ type:'time', time:{ unit:'hour', displayFormats:{ hour:'HH:mm' } } },
        x:{ type:'linear', min:0, ticks:{ stepSize:1, precision:0 } }
      },
      plugins:{ legend:{ display:false }, tooltip:{ enabled:false }, candlesPlugin:{ midnight:null } }
    }
  });
  // hover tooltip for P3
  const tip = el('p3Tip');
  (function attachP3Hover(){
    const c = p3Chart.canvas;
    function hide(){ tip.classList.add('hidden'); }
    function show(x, y, text){
      tip.textContent = text;
      tip.style.left = (x + 12) + 'px';
      tip.style.top  = (y + 12) + 'px';
      tip.classList.remove('hidden');
    }
    c.addEventListener('mouseleave', hide);
    c.addEventListener('mousemove', (ev)=>{
      const rect = c.getBoundingClientRect();
      const xpx  = ev.clientX - rect.left;
      const ypx  = ev.clientY - rect.top;

      const { chartArea:{top,bottom,left,right}, scales:{x,y} } = p3Chart;

      // out of plotting area → hide
      if (xpx < left || xpx > right || ypx < top || ypx > bottom) return hide();

      // bars we actually drew
      const bars = p3Chart.$candles || [];
      if (!bars.length) return hide();

      // same column width the plugin uses
      const colW = Math.max(8, ((right - left) / Math.max(1, bars.length + 2)) * 0.6);

      // find the bar under the cursor using pixel geometry
      let hit = null;
      for (const b of bars) {
        const cx = x.getPixelForValue(b.idx);
        const y1 = y.getPixelForValue(b.start);
        const y2 = y.getPixelForValue(b.end);
        const ya = Math.min(y1, y2), yb = Math.max(y1, y2);

        const insideX = (xpx >= cx - colW/2) && (xpx <= cx + colW/2);
        const insideY = (ypx >= ya) && (ypx <= yb);
        if (insideX && insideY) { hit = b; break; }
      }
      if (!hit) return hide();

      show(xpx, ypx, `${fmtHMS(hit.start)} → ${fmtHMS(hit.end)}`);
    });
  })();


  p4Chart = new Chart(el('p4Chart').getContext('2d'),{
    type:'bar',
    data:{ labels:['Setup','Run'], datasets:[{ data:[0,0], backgroundColor:[COLORS.yellow, COLORS.green] }] },
    options:{ responsive:true, maintainAspectRatio:false, plugins:{ legend:{ display:false }, title:{ display:true, text:'Coming soon'} }, scales:{ y:{ beginAtZero:true, max:24, ticks:{ stepSize:2 }, title:{ display:true, text:'Hours'} } } }
  });

  await apiMachines();
  const o = await apiOverviewToday();
  const statusMap={}; (o.overview||[]).forEach(item=>{ const code=item?.machine?.code||item?.CODE; if(!code) return; const col=(item?.current?.color||'unknown').toLowerCase(); statusMap[code]=col; });
  renderTabs(statusMap); updatePreview();

  contextInfo.textContent = `${MACHINE_META[ACTIVE]?.name||ACTIVE} · ${mainDate.value}`;
  globalErr.textContent='';

  await drawP1(); await drawP2(); startP3Auto(); drawP4();

  mainDate.addEventListener('change', ()=>{
    const ymd = mainDate.value;
    el('p1Date').value = ymd; el('p3Date').value = ymd;
    const ym = ymOf(ymd); el('p2Month').value = ym; el('p4Month').value = ym;
    contextInfo.textContent = `${MACHINE_META[ACTIVE]?.name||ACTIVE} · ${ymd}`;
    refreshAll();
    updateMainHero();
  });
  el('p1Date').addEventListener('change', ()=> drawP1());
  el('p2Month').addEventListener('change', ()=> drawP2());
  el('p3Date').addEventListener('change', ()=> startP3Auto());
  el('p4Month').addEventListener('change', ()=> drawP4());
})();


async function refreshAll(){
  globalErr.textContent='';
  try{
    updatePreview();
    contextInfo.textContent = `${MACHINE_META[ACTIVE]?.name||ACTIVE} · ${mainDate.value}`;
    await drawP1(); await drawP2(); startP3Auto(); drawP4();
  }catch(e){ globalErr.textContent = e.message||String(e); }
}
</script>

